(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.sicness = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
require("ace");
require("jquery");
var cc = __importStar(require("./sicxe_cc"));
var editor = ace.edit("editor");
editor.setTheme("ace/theme/monokai");
editor.session.setMode("ace/mode/sicxe");
$("#output").val("");
var textToArray = function (innerText) {
    return innerText.split("\n");
};
var arrayToText = function (array) {
    return array.reduce(function (acc, val) { return acc + "\n" + val; });
};
$("#btnCompile").click(function () {
    try {
        var arr = textToArray(editor.getValue());
        var comp = new cc.SicCompiler(arr);
        var output = ["-----lst-----"];
        output = output.concat(comp.makeLst());
        if (!comp.err) {
            output = output.concat("", "", "-----obj-----");
            output = output.concat(comp.makeObj());
        }
        else {
            output = output.concat("", "", "No obj generation due to errors in lst.");
        }
        $("#output").val(arrayToText(output));
    }
    catch (e) {
        alert(e.message);
    }
});
},{"./sicxe_cc":2,"ace":3,"jquery":3}],2:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.asHex = function (n) { return n.toString(16).toUpperCase(); };
exports.asWord = function (n) { return exports.asHex(n).padStart(6, "0"); };
exports.asByte = function (n) { return exports.asHex(n).padStart(2, "0"); };
exports.bytesToString = function (n) { return n.reduce(function (acc, val) { return acc + exports.asByte(val); }, ""); };
exports.sicMakeMask = function (nBits) {
    var m = 0x0;
    for (var i = 0; i < nBits; ++i) {
        m |= (1 << i);
    }
    return m;
};
exports.sicCheckUnsigned = function (val, nBits) {
    if (val < 0x0 || val > exports.sicMakeMask(nBits)) {
        throw new Error(exports.asHex(val) + " does not fit in an unsigned " + nBits + "-bit range");
    }
};
exports.sicMakeUnsigned = function (val, nBits) {
    var m = exports.sicMakeMask(nBits - 1);
    if (val < -m - 1 || val > m) {
        throw new Error(exports.asHex(val) + " does not fit in a signed " + nBits + "-bit range");
    }
    val >>>= 0;
    val &= exports.sicMakeMask(nBits);
    return val;
};
var SicSplit = (function () {
    function SicSplit(line) {
        line = line.replace(/\..*$/, "").toUpperCase();
        var lineArr = line.split(/\s+/);
        if (lineArr.length <= 1) {
            throw new Error("This line does not have the correct number of entries. Did you forget to put whitespace before the operand?");
        }
        this.tag = lineArr[0];
        this.op = lineArr[1];
        if (lineArr.length >= 3) {
            this.args = lineArr.slice(2).reduce(function (acc, val) { return acc + val; });
        }
        else {
            this.args = "";
        }
        if (this.tag.match(/^[A-Z]*$/) === null) {
            throw new Error("Labels can only contain A-Z (found \"" + this.tag + "\")");
        }
    }
    return SicSplit;
}());
exports.SicSplit = SicSplit;
var SicBytecode = (function () {
    function SicBytecode(mnemonic, opcode, format) {
        this.mnemonicPvt = mnemonic;
        this.opcodePvt = opcode;
        this.formatPvt = format;
    }
    Object.defineProperty(SicBytecode.prototype, "mnemonic", {
        get: function () {
            return this.mnemonicPvt;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SicBytecode.prototype, "opcode", {
        get: function () {
            return this.opcodePvt;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SicBytecode.prototype, "format", {
        get: function () {
            return this.formatPvt;
        },
        enumerable: true,
        configurable: true
    });
    return SicBytecode;
}());
exports.SicBytecode = SicBytecode;
exports.bytecodeTable = {};
var addBytecode = function (bc) {
    Object.defineProperty(exports.bytecodeTable, bc.mnemonic, {
        configurable: true,
        enumerable: true,
        value: bc,
        writable: false,
    });
};
addBytecode(new SicBytecode("ADD", 0x18, 3));
addBytecode(new SicBytecode("ADDF", 0x58, 3));
addBytecode(new SicBytecode("ADDR", 0x90, 2));
addBytecode(new SicBytecode("AND", 0x40, 3));
addBytecode(new SicBytecode("CLEAR", 0xB4, 2));
addBytecode(new SicBytecode("COMP", 0x28, 3));
addBytecode(new SicBytecode("COMPF", 0x88, 3));
addBytecode(new SicBytecode("COMPR", 0xA0, 2));
addBytecode(new SicBytecode("DIV", 0x24, 3));
addBytecode(new SicBytecode("DIVF", 0x64, 3));
addBytecode(new SicBytecode("DIVR", 0x9C, 2));
addBytecode(new SicBytecode("FIX", 0xC4, 1));
addBytecode(new SicBytecode("FLOAT", 0xC0, 1));
addBytecode(new SicBytecode("HIO", 0xF4, 1));
addBytecode(new SicBytecode("J", 0x3C, 3));
addBytecode(new SicBytecode("JEQ", 0x30, 3));
addBytecode(new SicBytecode("JGT", 0x34, 3));
addBytecode(new SicBytecode("JLT", 0x38, 3));
addBytecode(new SicBytecode("JSUB", 0x48, 3));
addBytecode(new SicBytecode("LDA", 0x00, 3));
addBytecode(new SicBytecode("LDB", 0x68, 3));
addBytecode(new SicBytecode("LDCH", 0x50, 3));
addBytecode(new SicBytecode("LDF", 0x70, 3));
addBytecode(new SicBytecode("LDL", 0x08, 3));
addBytecode(new SicBytecode("LDS", 0x6C, 3));
addBytecode(new SicBytecode("LDT", 0x74, 3));
addBytecode(new SicBytecode("LDX", 0x04, 3));
addBytecode(new SicBytecode("LPS", 0xD0, 3));
addBytecode(new SicBytecode("MUL", 0x20, 3));
addBytecode(new SicBytecode("MULF", 0x60, 3));
addBytecode(new SicBytecode("MULR", 0x98, 2));
addBytecode(new SicBytecode("NORM", 0xC8, 1));
addBytecode(new SicBytecode("OR", 0x44, 3));
addBytecode(new SicBytecode("RD", 0xD8, 3));
addBytecode(new SicBytecode("RMO", 0xAC, 2));
addBytecode(new SicBytecode("RSUB", 0x4C, 3));
addBytecode(new SicBytecode("SHIFTL", 0xA4, 2));
addBytecode(new SicBytecode("SHIFTR", 0xA8, 2));
addBytecode(new SicBytecode("SIO", 0xF0, 1));
addBytecode(new SicBytecode("SSK", 0xEC, 3));
addBytecode(new SicBytecode("STA", 0x0C, 3));
addBytecode(new SicBytecode("STB", 0x78, 3));
addBytecode(new SicBytecode("STCH", 0x54, 3));
addBytecode(new SicBytecode("STF", 0x80, 3));
addBytecode(new SicBytecode("STI", 0xD4, 3));
addBytecode(new SicBytecode("STL", 0x14, 3));
addBytecode(new SicBytecode("STS", 0x7C, 3));
addBytecode(new SicBytecode("STSW", 0xE8, 3));
addBytecode(new SicBytecode("STT", 0x84, 3));
addBytecode(new SicBytecode("STX", 0x10, 3));
addBytecode(new SicBytecode("SUB", 0x1C, 3));
addBytecode(new SicBytecode("SUBF", 0x5C, 3));
addBytecode(new SicBytecode("SUBR", 0x94, 2));
addBytecode(new SicBytecode("SVC", 0xB0, 2));
addBytecode(new SicBytecode("TD", 0xE0, 3));
addBytecode(new SicBytecode("TIO", 0xF8, 1));
addBytecode(new SicBytecode("TIX", 0x2C, 3));
addBytecode(new SicBytecode("TIXR", 0xB8, 2));
addBytecode(new SicBytecode("WD", 0xDC, 3));
var SicBase = (function () {
    function SicBase(val) {
        this.val = val;
        if (this.val instanceof SicPending && typeof this.val.val === "number") {
            this.val = this.val.val;
        }
    }
    SicBase.prototype.ready = function () {
        return typeof this.val === "number";
    };
    SicBase.prototype.makeReady = function (p) {
        if (typeof this.val === "number") {
            return;
        }
        if (typeof p === "number") {
            this.val = p;
            return;
        }
        var tagTab = p;
        var pending = this.val;
        this.val = pending.convert(tagTab, null);
    };
    return SicBase;
}());
exports.SicBase = SicBase;
var SicPending = (function () {
    function SicPending(val) {
        this.val = val;
    }
    SicPending.prototype.isLiteral = function () {
        return typeof this.val === "number";
    };
    SicPending.prototype.isTag = function () {
        return typeof this.val === "string";
    };
    SicPending.prototype.convert = function (tagTab, litTab) {
        var s;
        if (typeof this.val === "number") {
            if (litTab === null) {
                throw new Error("litTab is undefined but this SicPending is a literal");
            }
            s = litTab.getLitLoc(this.val);
            if (s === null) {
                throw new Error(this.val + "was not found in the literal table");
            }
        }
        else {
            if (tagTab === null) {
                throw new Error("tagTab is undefined but this SicPending is a tag");
            }
            s = tagTab[this.val];
            if (s === null) {
                throw new Error(this.val + "was not found in the tag table");
            }
        }
        return s;
    };
    return SicPending;
}());
exports.SicPending = SicPending;
var SicOpAddrType;
(function (SicOpAddrType) {
    SicOpAddrType[SicOpAddrType["immediate"] = 0] = "immediate";
    SicOpAddrType[SicOpAddrType["direct"] = 1] = "direct";
    SicOpAddrType[SicOpAddrType["indirect"] = 2] = "indirect";
})(SicOpAddrType = exports.SicOpAddrType || (exports.SicOpAddrType = {}));
var SicOpType;
(function (SicOpType) {
    SicOpType[SicOpType["f3"] = 0] = "f3";
    SicOpType[SicOpType["f4"] = 1] = "f4";
    SicOpType[SicOpType["legacy"] = 2] = "legacy";
})(SicOpType = exports.SicOpType || (exports.SicOpType = {}));
var SicOperandAddr = (function () {
    function SicOperandAddr(arg, type, litList, baserel) {
        var reDecimal = new RegExp("^(=|#|@)?(\\d+)(,X)?$");
        var reHex = new RegExp("^(=|#|@)?X'([0-9A-F]+)'(,X)?$");
        var reChar = new RegExp("^(=|#|@)?C'(.{1,3})'(,X)?$");
        var reTag = new RegExp("^(#|@)?([A-Z]+)(,X)?$");
        var getType = function (char) {
            switch (char) {
                case "#":
                    return SicOpAddrType.immediate;
                case "@":
                    return SicOpAddrType.indirect;
                case "=":
                default:
                    return SicOpAddrType.direct;
            }
        };
        var isLiteral = function (c) { return c !== undefined && c.charAt(0) === "="; };
        this.type = type;
        this.base = this.type === SicOpType.f3 ? baserel : undefined;
        this.pcrel = this.type === SicOpType.f3;
        var match;
        if ((match = arg.match(reDecimal)) !== null) {
            var x = parseInt(match[2], 10);
            if (isLiteral(match[1])) {
                litList.add(x);
                this.val = new SicPending(x);
            }
            else {
                this.val = x;
                this.pcrel = false;
            }
        }
        else if ((match = arg.match(reHex)) !== null) {
            var x = parseInt(match[2], 16);
            if (isLiteral(match[1])) {
                litList.add(x);
                this.val = new SicPending(x);
            }
            else {
                this.val = x;
                this.pcrel = false;
            }
        }
        else if ((match = arg.match(reChar)) !== null) {
            var bytes = [];
            for (var i = 0; i < match[2].length; ++i) {
                bytes.push(match[2].charCodeAt(i));
            }
            while (bytes.length < 3) {
                bytes = [0].concat(bytes);
            }
            var x = (bytes[0] << 16) + (bytes[1] << 8) + (bytes[2]);
            if (isLiteral(match[1])) {
                litList.add(x);
                this.val = new SicPending(x);
            }
            else {
                this.val = x;
                this.pcrel = false;
            }
        }
        else if ((match = arg.match(reTag)) != null) {
            this.val = new SicPending(match[2]);
        }
        else {
            throw new Error("Operand " + arg + " is not of any valid format.");
        }
        this.addr = getType(match[1]);
        this.indexed = match[3] != null;
        if (this.addr !== SicOpAddrType.direct && this.type === SicOpType.legacy) {
            throw new Error("SIC Legacy instructions can only use direct addressing");
        }
        this.rdy = !this.pcrel &&
            this.base === undefined &&
            typeof this.val === "number";
    }
    SicOperandAddr.prototype.ready = function () {
        return this.rdy;
    };
    SicOperandAddr.prototype.makeReady = function (pc, tagTab, litTab) {
        if (this.rdy) {
            return;
        }
        if (this.base !== undefined && !this.base.ready()) {
            this.base.makeReady(tagTab);
        }
        if (typeof this.val !== "number") {
            this.val = this.val.convert(tagTab, litTab);
        }
        var opLen;
        switch (this.type) {
            case SicOpType.f3:
                opLen = 12;
                break;
            case SicOpType.legacy:
                opLen = 15;
                break;
            case SicOpType.f4:
                opLen = 20;
                break;
            default:
                throw new Error("type is not valid");
        }
        if (this.pcrel) {
            try {
                this.val = exports.sicMakeUnsigned(this.val - pc, opLen);
                this.rdy = true;
                return;
            }
            catch (e) {
                this.pcrel = false;
            }
        }
        if (this.base) {
            try {
                this.val = exports.sicMakeUnsigned(this.val - this.base.val, opLen);
                this.rdy = true;
                return;
            }
            catch (e) {
                this.base = undefined;
            }
        }
        exports.sicCheckUnsigned(this.val, opLen);
        this.rdy = true;
    };
    SicOperandAddr.prototype.nixbpe = function () {
        if (!this.ready()) {
            throw new Error("nixbpe() can only be called when the value is ready.");
        }
        var n;
        var i;
        var x = this.indexed;
        var b = !this.pcrel && this.base !== undefined;
        var p = this.pcrel;
        var e = this.type === SicOpType.f4;
        switch (this.addr) {
            case SicOpAddrType.direct:
                if (this.type === SicOpType.legacy) {
                    n = false;
                    i = false;
                }
                else {
                    n = true;
                    i = true;
                }
                break;
            case SicOpAddrType.indirect:
                n = true;
                i = false;
                break;
            case SicOpAddrType.immediate:
                n = false;
                i = true;
                break;
            default:
                throw new Error("Registers do not have an nixbpe value");
        }
        var bytes = [0x0, 0x0];
        if (n) {
            bytes[0] |= 0x2;
        }
        if (i) {
            bytes[0] |= 0x1;
        }
        if (x) {
            bytes[1] |= 0x80;
        }
        if (b) {
            bytes[1] |= 0x40;
        }
        if (p) {
            bytes[1] |= 0x20;
        }
        if (e) {
            bytes[1] |= 0x10;
        }
        return bytes;
    };
    return SicOperandAddr;
}());
exports.SicOperandAddr = SicOperandAddr;
var SicFormat1 = (function () {
    function SicFormat1(line) {
        if (!SicFormat1.isFormat1(line.op)) {
            throw new Error(line.op + " is not a format 1 operation");
        }
        if (line.args !== "") {
            throw new Error("Format 1 arguments cannot have arguments");
        }
        this.bc = exports.bytecodeTable[line.op];
    }
    SicFormat1.isFormat1 = function (mnemonic) {
        var bc = exports.bytecodeTable[mnemonic];
        return bc !== undefined && bc.format === 1;
    };
    SicFormat1.prototype.ready = function () {
        return true;
    };
    SicFormat1.prototype.makeReady = function (loc, tagTab, litTab) {
        return;
    };
    SicFormat1.prototype.length = function () {
        return 1;
    };
    SicFormat1.prototype.toBytes = function () {
        return [this.bc.opcode];
    };
    return SicFormat1;
}());
exports.SicFormat1 = SicFormat1;
var SicFormat2 = (function () {
    function SicFormat2(line) {
        if (!SicFormat2.isFormat2(line.op)) {
            throw new Error(line.op + " is not a format 2 opcode");
        }
        this.bc = exports.bytecodeTable[line.op];
        var s = line.args.trim().split(/\s*,\s*/);
        if (s.length === 1) {
            s.push("0");
        }
        if (s.length !== 2) {
            throw new Error("This format 2 instruction has an invalid number of operands.");
        }
        var matcher = function (str) {
            var reRegister = new RegExp("^(A|X|L|PC|SW|B|S|T|F)$");
            var reHex = new RegExp("^X'([0-9A-Fa-f]+)'$");
            var reDec = new RegExp("^([0-9]+)$");
            var match;
            if ((match = str.match(reRegister)) !== null) {
                return exports.sicRegToDec(match[1]);
            }
            else if ((match = str.match(reHex)) !== null) {
                return parseInt(match[1], 16);
            }
            else if ((match = str.match(reDec)) !== null) {
                return parseInt(match[1], 10);
            }
            throw new Error(str + " is not a valid format 2 operand.");
        };
        this.op1 = matcher(s[0]);
        exports.sicCheckUnsigned(this.op1, 4);
        this.op2 = matcher(s[1]);
        exports.sicCheckUnsigned(this.op2, 4);
    }
    SicFormat2.isFormat2 = function (mnemonic) {
        var bc = exports.bytecodeTable[mnemonic];
        return bc !== undefined && bc.format === 2;
    };
    SicFormat2.prototype.ready = function () {
        return true;
    };
    SicFormat2.prototype.makeReady = function (loc, tagTab, litTab) {
        return;
    };
    SicFormat2.prototype.length = function () {
        return 2;
    };
    SicFormat2.prototype.toBytes = function () {
        var bytes = [0x00, 0x00];
        bytes[0] = this.bc.opcode;
        bytes[1] |= (this.op1 & 0x0F) << 4;
        bytes[1] |= (this.op2 & 0x0F);
        return bytes;
    };
    return SicFormat2;
}());
exports.SicFormat2 = SicFormat2;
var SicFormat3 = (function () {
    function SicFormat3(line, litSet, baserel) {
        if (!SicFormat3.isFormat3(line.op)) {
            throw new Error(line.op + " is not format 3");
        }
        this.bc = exports.bytecodeTable[line.op];
        this.op = new SicOperandAddr(line.args, SicOpType.f3, litSet, baserel);
    }
    SicFormat3.isFormat3 = function (mnemonic) {
        var bc = exports.bytecodeTable[mnemonic];
        return bc !== undefined && bc.format === 3;
    };
    SicFormat3.prototype.makeReady = function (loc, tagTab, litTab) {
        this.op.makeReady(loc + 3, tagTab, litTab);
    };
    SicFormat3.prototype.ready = function () {
        return this.op.ready();
    };
    SicFormat3.prototype.length = function () {
        return 3;
    };
    SicFormat3.prototype.toBytes = function () {
        if (!this.ready()) {
            throw new Error("Internal error: This SicFormat3 instruction is not ready.");
        }
        var bytes = this.op.nixbpe();
        bytes[0] |= (this.bc.opcode & 0xFC);
        bytes[1] |= (this.op.val & 0x0F00) >>> 8;
        bytes[2] = (this.op.val & 0xFF);
        return bytes;
    };
    return SicFormat3;
}());
exports.SicFormat3 = SicFormat3;
var SicFormatLegacy = (function () {
    function SicFormatLegacy(line, litList) {
        if (!SicFormatLegacy.isFormatLegacy(line.op)) {
            throw new Error(line.op + " is not SIC legacy format");
        }
        this.bc = exports.bytecodeTable[line.op.slice(1)];
        this.op = new SicOperandAddr(line.args, SicOpType.legacy, litList);
    }
    SicFormatLegacy.isFormatLegacy = function (mnemonic) {
        if (mnemonic.charAt(0) !== "*") {
            return false;
        }
        var bc = exports.bytecodeTable[mnemonic.slice(1)];
        return bc !== undefined && bc.format === 3;
    };
    SicFormatLegacy.prototype.makeReady = function (loc, tagTab, litTab) {
        this.op.makeReady(loc + this.length(), tagTab, litTab);
    };
    SicFormatLegacy.prototype.ready = function () {
        return this.op.ready();
    };
    SicFormatLegacy.prototype.length = function () {
        return 3;
    };
    SicFormatLegacy.prototype.toBytes = function () {
        if (!this.ready()) {
            throw new Error("Internal error: This SicFormatLegacy instruction is not ready.");
        }
        var bytes = this.op.nixbpe();
        bytes[0] |= (this.bc.opcode & 0xFC);
        bytes[1] |= (this.op.val & 0x7F00) >>> 8;
        bytes[2] = (this.op.val & 0xFF);
        return bytes;
    };
    return SicFormatLegacy;
}());
exports.SicFormatLegacy = SicFormatLegacy;
var SicFormat4 = (function () {
    function SicFormat4(line, litList) {
        if (!SicFormat4.isFormat4(line.op)) {
            throw new Error(line.op + " is not format 4");
        }
        this.bc = exports.bytecodeTable[line.op.slice(1)];
        this.op = new SicOperandAddr(line.args, SicOpType.f4, litList);
    }
    SicFormat4.isFormat4 = function (mnemonic) {
        if (mnemonic.charAt(0) !== "+") {
            return false;
        }
        var bc = exports.bytecodeTable[mnemonic.slice(1)];
        return bc !== undefined && bc.format === 3;
    };
    SicFormat4.prototype.makeReady = function (loc, tagTab, litTab) {
        this.op.makeReady(loc + this.length(), tagTab, litTab);
    };
    SicFormat4.prototype.ready = function () {
        return this.op.ready();
    };
    SicFormat4.prototype.length = function () {
        return 4;
    };
    SicFormat4.prototype.toBytes = function () {
        if (!this.ready()) {
            throw new Error("Internal error: This SicFormat4 instruction is not ready.");
        }
        var bytes = this.op.nixbpe();
        bytes[0] |= (this.bc.opcode & 0xFC);
        bytes[1] |= (this.op.val & 0x0F0000) >>> 16;
        bytes[2] = (this.op.val & 0xFF00) >>> 8;
        bytes[3] = (this.op.val & 0xFF);
        return bytes;
    };
    return SicFormat4;
}());
exports.SicFormat4 = SicFormat4;
var SicSpace = (function () {
    function SicSpace(line) {
        if (!SicSpace.isSpace(line.op)) {
            throw new Error("This mnemonic is not a space.");
        }
        this.mnemonic = line.op;
        var reDec = new RegExp("^(\\d+)$");
        var reHex = new RegExp("^X'([0-9A-Fa-f]+)'$");
        var reChar = new RegExp("^C'(.+)'$");
        var match;
        if ((match = line.args.match(reDec)) !== null) {
            this.arg = SicSpace.splitWord(parseInt(match[1], 10));
        }
        else if ((match = line.args.match(reHex)) !== null) {
            this.arg = SicSpace.splitWord(parseInt(match[1], 16));
        }
        else if ((match = line.args.match(reChar)) !== null) {
            this.arg = [];
            for (var i = 0; i < match[1].length; ++i) {
                this.arg.push(match[1].charCodeAt(i));
            }
        }
        else {
            throw new Error(line.args + " is not a valid operand format.");
        }
    }
    SicSpace.isSpace = function (mnemonic) {
        var re = new RegExp("^(WORD|BYTE)$");
        return re.test(mnemonic);
    };
    SicSpace.splitWord = function (n) {
        exports.sicCheckUnsigned(n, 24);
        return [(n & 0xFF0000) >>> 16, (n & 0xFF00) >>> 8, (n & 0xFF)];
    };
    SicSpace.prototype.ready = function () {
        return true;
    };
    SicSpace.prototype.makeReady = function (loc, tagTab, litTab) {
        return;
    };
    SicSpace.prototype.length = function () {
        switch (this.mnemonic) {
            case "WORD":
                return this.arg.length + (this.arg.length % 3 !== 0 ? 1 : 0);
            case "BYTE":
                return this.arg.length;
            default:
                throw new Error(this.mnemonic + " is invalid. this is a ultra mega bug");
        }
    };
    SicSpace.prototype.toBytes = function () {
        var a = [];
        switch (this.mnemonic) {
            case "WORD":
                for (var i = 0; i < this.arg.length % 3; ++i) {
                    a.push(0x00);
                }
                this.arg.forEach(function (val) { return a.push(val); });
                return a;
            case "BYTE":
                return this.arg;
            default:
                throw new Error("Mnemonic is invalid.");
        }
    };
    return SicSpace;
}());
exports.SicSpace = SicSpace;
var SicLiteral = (function () {
    function SicLiteral(val) {
        this.val = val;
    }
    SicLiteral.prototype.length = function () {
        return 3;
    };
    SicLiteral.prototype.ready = function () {
        return true;
    };
    SicLiteral.prototype.makeReady = function (loc, tagTab, litTab) {
        return;
    };
    SicLiteral.prototype.toBytes = function () {
        return SicSpace.splitWord(this.val);
    };
    return SicLiteral;
}());
exports.SicLiteral = SicLiteral;
var SicLstEntry = (function () {
    function SicLstEntry(source, bcData) {
        this.source = source;
        if (typeof bcData === "string") {
            this.bcData = undefined;
            this.errmsg = bcData;
        }
        else {
            this.bcData = bcData;
            this.errmsg = undefined;
        }
    }
    SicLstEntry.prototype.hasInstruction = function () {
        return this.bcData !== undefined && this.bcData.inst !== undefined;
    };
    SicLstEntry.prototype.byteCode = function () {
        if (!(this.bcData !== undefined && this.bcData.inst !== undefined)) {
            throw new Error("This SicLstEntry does not have an instruction in it");
        }
        return this.bcData.inst.toBytes();
    };
    SicLstEntry.prototype.byteString = function () {
        return exports.bytesToString(this.byteCode());
    };
    return SicLstEntry;
}());
exports.SicLstEntry = SicLstEntry;
var SicLitTab = (function () {
    function SicLitTab() {
        this.ltorgs = [];
        this.pending = new Set();
    }
    SicLitTab.prototype.getLitLoc = function (n, pc) {
        if (pc === void 0) { pc = 0; }
        var diffMin = Number.MAX_SAFE_INTEGER;
        var loc = null;
        this.ltorgs.forEach(function (lt) {
            if (lt.val === n && diffMin > Math.min(lt.loc - pc, lt.loc)) {
                diffMin = Math.min(lt.loc - pc, lt.loc);
                loc = lt.loc;
            }
        });
        return loc;
    };
    SicLitTab.prototype.createOrg = function (loc) {
        var l = loc;
        var m = [];
        var lt = this.pending.forEach(function (v) {
            m.push({ loc: l, val: v });
            l += 3;
        });
        this.ltorgs = this.ltorgs.concat(m);
        this.pending = new Set();
        return m;
    };
    SicLitTab.prototype.add = function (n) {
        if (this.getLitLoc(n) === null) {
            this.pending.add(n);
        }
    };
    SicLitTab.prototype.hasPending = function (n) {
        if (n === undefined) {
            return this.pending.size > 0;
        }
        return this.pending.has(n);
    };
    return SicLitTab;
}());
exports.SicLitTab = SicLitTab;
var SicUseTab = (function () {
    function SicUseTab(startloc) {
        this.ALOC = this.RLOC = this.startloc = startloc;
        this.useTab = {};
        this.currentUse = "";
    }
    Object.defineProperty(SicUseTab.prototype, "aloc", {
        get: function () {
            return this.ALOC;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SicUseTab.prototype, "rloc", {
        get: function () {
            return this.RLOC;
        },
        enumerable: true,
        configurable: true
    });
    SicUseTab.prototype.inc = function (n) {
        this.RLOC += n;
        this.ALOC += n;
    };
    SicUseTab.prototype.use = function (label) {
        this.useTab[this.currentUse] = this.RLOC;
        this.currentUse = label;
        var x = this.useTab[label];
        if (x === undefined) {
            x = this.startloc;
        }
        this.RLOC = x;
    };
    return SicUseTab;
}());
exports.SicUseTab = SicUseTab;
var SicCsect = (function () {
    function SicCsect(startAddr) {
        this.lst = [];
        this.litTab = new SicLitTab();
        this.tagTab = {};
        this.equTab = {};
        this.useTab = new SicUseTab(startAddr);
        this.extDefTab = {};
        this.extRefTab = [];
    }
    SicCsect.prototype.setStartAddr = function (startAddr) {
        this.useTab = new SicUseTab(startAddr);
    };
    return SicCsect;
}());
exports.SicCsect = SicCsect;
var SicCsectTab = (function () {
    function SicCsectTab() {
        var _this = this;
        this.currentSect = "";
        this.csects = {};
        this.csects[this.currentSect] = new SicCsect(0);
        this.lst = [];
        var parseNum = function (val) {
            var reDec = new RegExp("^(\\d+)$");
            var reHex = new RegExp("^X'([0-9A-Fa-f]+)'$");
            var reChar = new RegExp("^C'.{1,3}'$");
            var match;
            if ((match = val.match(reDec)) !== null) {
                return parseInt(match[1], 10);
            }
            if ((match = val.match(reHex)) !== null) {
                return parseInt(match[1], 16);
            }
            if ((match = val.match(reChar)) !== null) {
                var x = 0;
                for (var ptr = 0, s = match[1]; s !== ""; ptr += 8, s = s.slice(0, -1)) {
                    x += s.charCodeAt(s.length - 1) << ptr;
                }
                return x;
            }
            throw new Error(val + " was not of a valid numeric format.");
        };
        this.directives = {
            RESW: function (source, split) {
                _this.addLst(new SicLstEntry(source, { aloc: _this.current.useTab.aloc, rloc: _this.current.useTab.rloc, inst: undefined }));
                _this.current.useTab.inc(3 * parseNum(split.args));
            },
            RESB: function (source, split) {
                _this.addLst(new SicLstEntry(source, { aloc: _this.current.useTab.aloc, rloc: _this.current.useTab.rloc, inst: undefined }));
                _this.current.useTab.inc(parseNum(split.args));
            },
            START: function (source, split) {
                if (_this.currentSect !== "" || _this.current.lst.length !== 0) {
                    throw new Error("START can only be used as the first line of a program.");
                }
                _this.current.setStartAddr(parseInt(split.args, 16));
                _this.addLst(new SicLstEntry(source, { aloc: _this.current.useTab.aloc, rloc: _this.current.useTab.rloc, inst: undefined }));
                _this.startData = { name: split.tag, loc: _this.current.useTab.aloc };
            },
            END: function (source, split) {
                _this.csect("");
                if ((_this.startData === undefined && split.args !== "") ||
                    (_this.startData !== undefined && split.args !== _this.startData.name)) {
                    throw new Error("END label must be the same as the start label.");
                }
                _this.addLst(new SicLstEntry(source, { aloc: _this.current.useTab.aloc, rloc: _this.current.useTab.rloc, inst: undefined }));
            },
            BASE: function (source, split) {
                try {
                    _this.current.base = new SicBase(parseNum(split.args));
                }
                catch (e) {
                    _this.current.base = new SicBase(new SicPending(split.args));
                }
                _this.addLst(new SicLstEntry(source));
            },
            NOBASE: function (source, split) {
                _this.current.base = undefined;
                _this.addLst(new SicLstEntry(source));
            },
            LTORG: function (source, split) {
                _this.addLst(new SicLstEntry(source));
                var l = _this.current.litTab.createOrg(_this.current.useTab.aloc);
                l.forEach(function (v) {
                    _this.addLst(new SicLstEntry("LTORG-WORD X'" + exports.asHex(v.val) + "'", { aloc: _this.current.useTab.aloc, rloc: _this.current.useTab.rloc, inst: new SicLiteral(v.val) }));
                    _this.current.useTab.inc(3);
                });
            },
            EQU: function (source, split) {
                if (split.tag === "") {
                    throw new Error("EQU needs a non-empty label.");
                }
                if (_this.current.equTab[split.args] !== undefined) {
                    throw new Error("EQU " + split.args + " was already defined.");
                }
                _this.current.equTab[split.tag] = split.args;
                _this.addLst(new SicLstEntry(source));
            },
            USE: function (source, split) {
                _this.current.useTab.use(split.args);
                _this.addLst(new SicLstEntry(source));
            },
            CSECT: function (source, split) {
                _this.current.extDefTab[split.tag] = _this.current.useTab.aloc;
                _this.addLst(new SicLstEntry(source));
                _this.csect(split.tag);
            },
            EXTDEF: function (source, split) {
                _this.addLst(new SicLstEntry(source));
                _this.current.extDefTab[split.tag] = _this.current.useTab.aloc;
            },
            EXTREF: function (source, split) {
                var s = split.args.split(",");
                _this.addLst(new SicLstEntry(source));
                _this.current.extRefTab = _this.current.extRefTab.concat(split.args.split(","));
                s.forEach(function (r) { return _this.current.tagTab[r] = 0; });
            },
        };
    }
    SicCsectTab.prototype.isDirective = function (mnemonic) {
        return this.directives[mnemonic] !== undefined;
    };
    SicCsectTab.prototype.addLst = function (l) {
        this.lst.push(l);
        this.current.lst.push(l);
    };
    SicCsectTab.prototype.makeLst = function () {
        var s = ["n"];
        s[0] = "n    \taloc \trloc \tbytecode\tsource";
        s[1] = "-----\t-----\t-----\t--------\t------";
        var i = 1;
        return s.concat(this.lst.map(function (ls) {
            var astr = ls.bcData === undefined ? "" : exports.asHex(ls.bcData.aloc);
            var rstr = ls.bcData === undefined ? "" : exports.asHex(ls.bcData.rloc);
            var inststr = ls.hasInstruction() ? ls.byteString() : "";
            var istr = exports.asHex(i);
            ++i;
            var msg = istr.padEnd(5, " ") + "\t" +
                astr.padEnd(5, " ") + "\t" +
                rstr.padEnd(5, " ") + "\t" +
                inststr.padEnd(8, " ") + "\t" +
                ls.source;
            if (ls.errmsg !== undefined) {
                msg += "\n* Error: " + ls.errmsg + " *";
            }
            return msg;
        }));
    };
    SicCsectTab.prototype.makeObj = function () {
        var s = [];
        var mkH = function (len, loc, name) {
            if (loc === undefined) {
                loc = 0;
            }
            if (name === undefined) {
                name = "";
            }
            return "H" + name + " " + exports.asWord(loc) + exports.asWord(len);
        };
        var mkD = function (defs) {
            return "D" + Object.keys(defs).reduce(function (a, v) { return a + v + exports.asWord(defs[v]); }, "");
        };
        var mkR = function (refs) {
            return "R" + Object.keys(refs).reduce(function (a, v) { return a + v + " "; }).trim();
        };
        var mkT = function (arr) {
            var buf = [];
            arr.forEach(function (l) {
                if (l.bcData === undefined || l.bcData.inst === undefined) {
                    return;
                }
                buf.push("T" + exports.asWord(l.bcData.aloc) + exports.asByte(l.bcData.inst.length()) + exports.bytesToString(l.bcData.inst.toBytes()));
            });
            return buf;
        };
        var mkE = function (loc) {
            if (loc === undefined) {
                return "E";
            }
            return "E" + exports.asWord(loc);
        };
        var getLen = function (a) {
            var start = 0;
            var end = 0;
            for (var _i = 0, a_1 = a; _i < a_1.length; _i++) {
                var b = a_1[_i];
                if (b.bcData !== undefined) {
                    start = b.bcData.aloc;
                    break;
                }
            }
            for (var i = a.length - 1; i >= 0; --i) {
                var bc = a[i].bcData;
                if (bc !== undefined) {
                    end = bc.aloc + (bc.inst !== undefined ? bc.inst.length() : 0);
                    break;
                }
            }
            return end - start;
        };
        var sloc = this.startData !== undefined ? this.startData.loc : 0;
        var sname = this.startData !== undefined ? this.startData.name : "";
        s.push(mkH(getLen(this.csects[""].lst), sloc, sname));
        if (Object.keys(this.csects[""].extDefTab).length !== 0) {
            s.push(mkD(this.csects[""].extDefTab));
        }
        if (Object.keys(this.csects[""].extRefTab).length !== 0) {
            s.push(mkR(this.csects[""].extRefTab));
        }
        s = s.concat(mkT(this.csects[""].lst));
        s.push(mkE(sloc));
        this.forEachAux(function (c, n) {
            s.push(mkH(getLen(c.lst), 0, n));
            if (Object.keys(c.extDefTab).length !== 0) {
                s.push(mkD(c.extDefTab));
            }
            if (Object.keys(c.extRefTab).length !== 0) {
                s.push(mkR(c.extRefTab));
            }
            s = s.concat(mkT(c.lst));
            s.push(mkE());
        });
        return s;
    };
    Object.defineProperty(SicCsectTab.prototype, "current", {
        get: function () {
            return this.csects[this.currentSect];
        },
        enumerable: true,
        configurable: true
    });
    SicCsectTab.prototype.csect = function (newSect) {
        this.currentSect = newSect;
        if (this.csects[this.currentSect] === undefined) {
            this.csects[this.currentSect] = new SicCsect(0);
        }
    };
    Object.defineProperty(SicCsectTab.prototype, "default", {
        get: function () {
            return this.csects[""];
        },
        enumerable: true,
        configurable: true
    });
    SicCsectTab.prototype.forEach = function (callback) {
        var _this = this;
        var curBuf = this.currentSect;
        Object.keys(this.csects).forEach(function (c) {
            _this.currentSect = c;
            callback(_this.csects[c], c);
        });
        this.currentSect = curBuf;
    };
    SicCsectTab.prototype.forEachAux = function (callback) {
        var _this = this;
        var curBuf = this.currentSect;
        Object.keys(this.csects).forEach(function (c) {
            if (c === "") {
                return;
            }
            _this.currentSect = c;
            callback(_this.csects[c], c);
        });
        this.currentSect = curBuf;
    };
    return SicCsectTab;
}());
exports.SicCsectTab = SicCsectTab;
var SicCompiler = (function () {
    function SicCompiler(lines) {
        var _this = this;
        this.ctab = new SicCsectTab();
        this.errflag = false;
        lines.forEach(function (val) {
            try {
                if (val.replace(/\..*$/, "").trim() === "") {
                    return;
                }
                var split = new SicSplit(val);
                var instr = void 0;
                split.args.replace(/(#|@|=)\*$/, "$1" + _this.ctab.current.useTab.aloc.toString(10));
                for (var _i = 0, _a = Object.keys(_this.ctab.current.equTab); _i < _a.length; _i++) {
                    var key = _a[_i];
                    if (split.args.match(key) === null) {
                        continue;
                    }
                    for (var s = _this.ctab.current.equTab[key]; s !== undefined; s = _this.ctab.current.equTab[s]) {
                        split.args = split.args.replace(key, _this.ctab.current.equTab[key]);
                    }
                    break;
                }
                if (split.tag !== undefined) {
                    _this.ctab.current.tagTab[split.tag] = _this.ctab.current.useTab.aloc;
                }
                if (_this.ctab.isDirective(split.op)) {
                    _this.ctab.directives[split.op](val, split);
                    return;
                }
                if (SicFormat1.isFormat1(split.op)) {
                    instr = new SicFormat1(split);
                }
                else if (SicFormat2.isFormat2(split.op)) {
                    instr = new SicFormat2(split);
                }
                else if (SicFormat3.isFormat3(split.op)) {
                    instr = new SicFormat3(split, _this.ctab.current.litTab, _this.ctab.current.base);
                }
                else if (SicFormat4.isFormat4(split.op)) {
                    instr = new SicFormat4(split, _this.ctab.current.litTab);
                }
                else if (SicFormatLegacy.isFormatLegacy(split.op)) {
                    instr = new SicFormatLegacy(split, _this.ctab.current.litTab);
                }
                else if (SicSpace.isSpace(split.op)) {
                    instr = new SicSpace(split);
                }
                else {
                    throw new Error(split.op + " is not a valid mnemonic.");
                }
                _this.ctab.addLst(new SicLstEntry(val, { aloc: _this.ctab.current.useTab.aloc, rloc: _this.ctab.current.useTab.rloc, inst: instr }));
                _this.ctab.current.useTab.inc(instr.length());
            }
            catch (e) {
                _this.errflag = true;
                _this.ctab.addLst(new SicLstEntry(val, e.message));
            }
        });
        this.ctab.forEach(function (p) {
            if (p.litTab.hasPending()) {
                _this.ctab.directives["LTORG"]("AUTO-LTORG", new SicSplit("\tAUTO-LTORG"));
            }
        });
        this.ctab.forEach(function (p) {
            p.lst.forEach(function (l) {
                if (l.bcData !== undefined && l.bcData.inst !== undefined && !l.bcData.inst.ready()) {
                    l.bcData.inst.makeReady(l.bcData.aloc, p.tagTab, p.litTab);
                }
            });
        });
    }
    SicCompiler.prototype.makeLst = function () {
        return this.ctab.makeLst();
    };
    SicCompiler.prototype.makeObj = function () {
        return this.ctab.makeObj();
    };
    Object.defineProperty(SicCompiler.prototype, "err", {
        get: function () {
            return this.errflag;
        },
        enumerable: true,
        configurable: true
    });
    return SicCompiler;
}());
exports.SicCompiler = SicCompiler;
exports.sicRegToDec = function (reg) {
    switch (reg) {
        case "A":
            return 0;
        case "X":
            return 1;
        case "L":
            return 2;
        case "B":
            return 3;
        case "S":
            return 4;
        case "T":
            return 5;
        case "F":
            return 6;
        case "PC":
            return 8;
        case "SW":
            return 9;
        default:
            throw new Error("reg type " + reg + " is not valid");
    }
};
exports.sicDecToReg = function (reg) {
    switch (reg) {
        case 0:
            return "A";
        case 1:
            return "X";
        case 2:
            return "L";
        case 3:
            return "B";
        case 4:
            return "S";
        case 5:
            return "T";
        case 6:
            return "F";
        case 8:
            return "PC";
        case 9:
            return "SW";
        default:
            throw new Error("reg no " + reg + " is not valid");
    }
};
},{}],3:[function(require,module,exports){

},{}]},{},[1])(1)
});

//# sourceMappingURL=sicness.min.js.map
