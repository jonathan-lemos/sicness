{"version":3,"sources":["node_modules/browser-pack/_prelude.js","dist/SicCompiler/SicBase.js","dist/SicCompiler/SicBytecode.js","dist/SicCompiler/SicCompiler.js","dist/SicCompiler/SicCsect.js","dist/SicCompiler/SicFmt.js","dist/SicCompiler/SicFormat1.js","dist/SicCompiler/SicFormat2.js","dist/SicCompiler/SicFormat3.js","dist/SicCompiler/SicFormat4.js","dist/SicCompiler/SicFormatLegacy.js","dist/SicCompiler/SicLitTab.js","dist/SicCompiler/SicLiteral.js","dist/SicCompiler/SicLstEntry.js","dist/SicCompiler/SicOperandAddr.js","dist/SicCompiler/SicPending.js","dist/SicCompiler/SicRegConvert.js","dist/SicCompiler/SicSpace.js","dist/SicCompiler/SicSplit.js","dist/SicCompiler/SicUnsigned.js","dist/SicCompiler/SicUseTab.js","dist/app.js"],"names":["f","exports","module","define","amd","window","global","self","this","sicness","r","e","n","t","o","i","c","require","u","a","Error","code","p","call","length","1","Object","defineProperty","value","SicPending_1","SicBase","val","SicPending","prototype","ready","makeReady","tagTab","pending","convert","SicBytecode","mnemonic","opcode","format","mnemonicPvt","opcodePvt","formatPvt","get","enumerable","configurable","bytecodeTable","addBytecode","bc","writable","SicCsect_1","SicFormat1_1","SicFormat2_1","SicFormat3_1","SicFormat4_1","SicFormatLegacy_1","SicLstEntry_1","SicSpace_1","SicSplit_1","SicCompiler","lines","_this","ctab","SicCsectTab","errflag","forEach","replace","trim","split","SicSplit","instr","args","current","useTab","rloc","toString","_i","_a","keys","equTab","key","match","s","undefined","tag","isDirective","op","directives","SicFormat1","isFormat1","SicFormat2","isFormat2","SicFormat3","isFormat3","SicFormat4","isFormat4","SicFormatLegacy","isFormatLegacy","SicSpace","isSpace","addLst","SicLstEntry","loc","inst","inc","message","litTab","hasPending","correct","lst","l","bcData","res","extRefTab","modRecs","push","len","symbol","str","errmsg","makeLst","makeObj","SicBase_1","SicFmt_1","SicLiteral_1","SicLitTab_1","SicUseTab_1","SicCsect","startAddr","SicLitTab","SicUseTab","extDefTab","Set","setStartAddr","objcodeArr","m","filter","q","sort","b","d","map","toBytes","objcodeLen","currentSect","csects","parseNum","reDec","RegExp","reHex","reChar","parseInt","x","ptr","slice","charCodeAt","RESW","source","RESB","START","startData","name","aloc","END","cs","csect","BASE","base","NOBASE","SILENT_LTORG","createOrg","v","asHex","SicLiteral","LTORG","EQU","USE","use","CSECT","EXTDEF","add","EXTREF","has","litPool","concat","ls","astr","rstr","inststr","hasInstruction","byteString","istr","msg","padEnd","mkH","asWord","mkD","defs","size","mkR","refs","mkT","arr","buf","asByte","bytesToString","mkE","mkM","modrec","sloc","sname","ss","forEachAux","sss","newSect","callback","curBuf","toUpperCase","padStart","reduce","acc","SicBytecode_1","line","SicRegConvert_1","SicUnsigned_1","matcher","reRegister","sicRegToDec","op1","sicCheckUnsigned","op2","bytes","SicOperandAddr_1","SicOperandAddr","SicOpType","f3","nixbpe","f4","charAt","legacy","ltorgs","getLitLoc","pc","diffMin","Number","MAX_SAFE_INTEGER","lt","Math","min","splitWord","byteCode","SicOpAddrType","arg","type","reDecimal","reTag","isLiteral","pcrel","addr","direct","indexed","rdy","char","immediate","indirect","getType","opLen","sicMakeUnsigned","isTag","reg","sicDecToReg","func","splitByte","test","lineArr","sicMakeMask","nBits","SicLocPair","startloc","ALOC","label","locsent","curIndex","curUse","finalPair","index","find","prev","SicCompiler_1","editor","ace","edit","setTheme","session","setMode","$","click","getValue","comp","output","err","alert"],"mappings":"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AAA,IAAAX,EAAA,MAAA,GAAA,IACAW,EAAA,IAAAX,EAAA,OAAA,GAAA,IACAW,EAAA,IAAAX,EAAA,MAAA,EAAA,IACAW,EAAA,IAAAX,EAAA,MAAA,IAAA,IACAW,EAAA,IAAAX,EAAA,OAAA,GAAA,IACAW,EAAA,IAAAX,EAAA,MAAA,IAAA,IACAW,EAAA,IAAAX,EAAA,MAAA,EAAA,IACAW,EAAA,IAAAX,EAAA,MAAA,IAAA,IACAW,EAAA,IAAAX,EAAA,MAAA,IAAA,IACAW,EAAA,IAAAX,EAAA,MAAA,EAAA,IACAW,EAAA,IAAAX,EAAA,MAAA,IAAA,IACAW,EAAA,IAAAX,EAAA,MAAA,GAAA,IACAW,EAAA,IAAAX,EAAA,OAAA,GAAA,IACAW,EAAA,IAAAX,EAAA,OAAA,IAAA,IACAW,EAAA,IAAAX,EAAA,OAAA,IAAA,IACAW,EAAA,IAAAX,EAAA,KAAA,GAAA,IACAW,EAAA,IAAAX,EAAA,KAAA,IAAA,IACAW,EAAA,IAAAX,EAAA,MAAA,IAAA,IACAW,EAAA,IAAAX,EAAA,OAAA,GAAA,IACAW,EAAA,IAAAX,EAAA,SAAA,IAAA,IACAW,EAAA,IAAAX,EAAA,SAAA,IAAA,IACAW,EAAA,IAAAX,EAAA,MAAA,IAAA,IACAW,EAAA,IAAAX,EAAA,MAAA,IAAA,IACAW,EAAA,IAAAX,EAAA,MAAA,GAAA,IACAW,EAAA,IAAAX,EAAA,MAAA,IAAA,IACAW,EAAA,IAAAX,EAAA,OAAA,GAAA,IACAW,EAAA,IAAAX,EAAA,MAAA,IAAA,IACAW,EAAA,IAAAX,EAAA,MAAA,IAAA,IACAW,EAAA,IAAAX,EAAA,MAAA,GAAA,IACAW,EAAA,IAAAX,EAAA,MAAA,IAAA,IACAW,EAAA,IAAAX,EAAA,OAAA,IAAA,IACAW,EAAA,IAAAX,EAAA,MAAA,IAAA,IACAW,EAAA,IAAAX,EAAA,MAAA,GAAA,IACAW,EAAA,IAAAX,EAAA,MAAA,GAAA,IACAW,EAAA,IAAAX,EAAA,OAAA,GAAA,IACAW,EAAA,IAAAX,EAAA,OAAA,IAAA,IACAW,EAAA,IAAAX,EAAA,MAAA,IAAA,IACAW,EAAA,IAAAX,EAAA,K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","file":"sicness.min.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SicPending_1 = require(\"./SicPending\");\nvar SicBase = (function () {\n    function SicBase(val) {\n        this.val = val;\n        if (this.val instanceof SicPending_1.SicPending && typeof this.val.val === \"number\") {\n            this.val = this.val.val;\n        }\n    }\n    SicBase.prototype.ready = function () {\n        return typeof this.val === \"number\";\n    };\n    SicBase.prototype.makeReady = function (p) {\n        if (typeof this.val === \"number\") {\n            return;\n        }\n        if (typeof p === \"number\") {\n            this.val = p;\n            return;\n        }\n        var tagTab = p;\n        var pending = this.val;\n        this.val = pending.convert(tagTab, null, null);\n    };\n    return SicBase;\n}());\nexports.SicBase = SicBase;","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SicBytecode = (function () {\n    function SicBytecode(mnemonic, opcode, format) {\n        this.mnemonicPvt = mnemonic;\n        this.opcodePvt = opcode;\n        this.formatPvt = format;\n    }\n    Object.defineProperty(SicBytecode.prototype, \"mnemonic\", {\n        get: function () {\n            return this.mnemonicPvt;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SicBytecode.prototype, \"opcode\", {\n        get: function () {\n            return this.opcodePvt;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SicBytecode.prototype, \"format\", {\n        get: function () {\n            return this.formatPvt;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return SicBytecode;\n}());\nexports.SicBytecode = SicBytecode;\nexports.bytecodeTable = {};\nvar addBytecode = function (bc) {\n    Object.defineProperty(exports.bytecodeTable, bc.mnemonic, {\n        configurable: true,\n        enumerable: true,\n        value: bc,\n        writable: false,\n    });\n};\naddBytecode(new SicBytecode(\"ADD\", 0x18, 3));\naddBytecode(new SicBytecode(\"ADDF\", 0x58, 3));\naddBytecode(new SicBytecode(\"ADDR\", 0x90, 2));\naddBytecode(new SicBytecode(\"AND\", 0x40, 3));\naddBytecode(new SicBytecode(\"CLEAR\", 0xB4, 2));\naddBytecode(new SicBytecode(\"COMP\", 0x28, 3));\naddBytecode(new SicBytecode(\"COMPF\", 0x88, 3));\naddBytecode(new SicBytecode(\"COMPR\", 0xA0, 2));\naddBytecode(new SicBytecode(\"DIV\", 0x24, 3));\naddBytecode(new SicBytecode(\"DIVF\", 0x64, 3));\naddBytecode(new SicBytecode(\"DIVR\", 0x9C, 2));\naddBytecode(new SicBytecode(\"FIX\", 0xC4, 1));\naddBytecode(new SicBytecode(\"FLOAT\", 0xC0, 1));\naddBytecode(new SicBytecode(\"HIO\", 0xF4, 1));\naddBytecode(new SicBytecode(\"J\", 0x3C, 3));\naddBytecode(new SicBytecode(\"JEQ\", 0x30, 3));\naddBytecode(new SicBytecode(\"JGT\", 0x34, 3));\naddBytecode(new SicBytecode(\"JLT\", 0x38, 3));\naddBytecode(new SicBytecode(\"JSUB\", 0x48, 3));\naddBytecode(new SicBytecode(\"LDA\", 0x00, 3));\naddBytecode(new SicBytecode(\"LDB\", 0x68, 3));\naddBytecode(new SicBytecode(\"LDCH\", 0x50, 3));\naddBytecode(new SicBytecode(\"LDF\", 0x70, 3));\naddBytecode(new SicBytecode(\"LDL\", 0x08, 3));\naddBytecode(new SicBytecode(\"LDS\", 0x6C, 3));\naddBytecode(new SicBytecode(\"LDT\", 0x74, 3));\naddBytecode(new SicBytecode(\"LDX\", 0x04, 3));\naddBytecode(new SicBytecode(\"LPS\", 0xD0, 3));\naddBytecode(new SicBytecode(\"MUL\", 0x20, 3));\naddBytecode(new SicBytecode(\"MULF\", 0x60, 3));\naddBytecode(new SicBytecode(\"MULR\", 0x98, 2));\naddBytecode(new SicBytecode(\"NORM\", 0xC8, 1));\naddBytecode(new SicBytecode(\"OR\", 0x44, 3));\naddBytecode(new SicBytecode(\"RD\", 0xD8, 3));\naddBytecode(new SicBytecode(\"RMO\", 0xAC, 2));\naddBytecode(new SicBytecode(\"RSUB\", 0x4C, 3));\naddBytecode(new SicBytecode(\"SHIFTL\", 0xA4, 2));\naddBytecode(new SicBytecode(\"SHIFTR\", 0xA8, 2));\naddBytecode(new SicBytecode(\"SIO\", 0xF0, 1));\naddBytecode(new SicBytecode(\"SSK\", 0xEC, 3));\naddBytecode(new SicBytecode(\"STA\", 0x0C, 3));\naddBytecode(new SicBytecode(\"STB\", 0x78, 3));\naddBytecode(new SicBytecode(\"STCH\", 0x54, 3));\naddBytecode(new SicBytecode(\"STF\", 0x80, 3));\naddBytecode(new SicBytecode(\"STI\", 0xD4, 3));\naddBytecode(new SicBytecode(\"STL\", 0x14, 3));\naddBytecode(new SicBytecode(\"STS\", 0x7C, 3));\naddBytecode(new SicBytecode(\"STSW\", 0xE8, 3));\naddBytecode(new SicBytecode(\"STT\", 0x84, 3));\naddBytecode(new SicBytecode(\"STX\", 0x10, 3));\naddBytecode(new SicBytecode(\"SUB\", 0x1C, 3));\naddBytecode(new SicBytecode(\"SUBF\", 0x5C, 3));\naddBytecode(new SicBytecode(\"SUBR\", 0x94, 2));\naddBytecode(new SicBytecode(\"SVC\", 0xB0, 2));\naddBytecode(new SicBytecode(\"TD\", 0xE0, 3));\naddBytecode(new SicBytecode(\"TIO\", 0xF8, 1));\naddBytecode(new SicBytecode(\"TIX\", 0x2C, 3));\naddBytecode(new SicBytecode(\"TIXR\", 0xB8, 2));\naddBytecode(new SicBytecode(\"WD\", 0xDC, 3));","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SicCsect_1 = require(\"./SicCsect\");\nvar SicFormat1_1 = require(\"./SicFormat1\");\nvar SicFormat2_1 = require(\"./SicFormat2\");\nvar SicFormat3_1 = require(\"./SicFormat3\");\nvar SicFormat4_1 = require(\"./SicFormat4\");\nvar SicFormatLegacy_1 = require(\"./SicFormatLegacy\");\nvar SicLstEntry_1 = require(\"./SicLstEntry\");\nvar SicSpace_1 = require(\"./SicSpace\");\nvar SicSplit_1 = require(\"./SicSplit\");\nvar SicCompiler = (function () {\n    function SicCompiler(lines) {\n        var _this = this;\n        this.ctab = new SicCsect_1.SicCsectTab();\n        this.errflag = false;\n        lines.forEach(function (val) {\n            try {\n                if (val.replace(/\\..*$/, \"\").trim() === \"\") {\n                    return;\n                }\n                var split = new SicSplit_1.SicSplit(val);\n                var instr = void 0;\n                split.args.replace(/(#|@|=)\\*$/, \"$1\" + _this.ctab.current.useTab.rloc.toString(10));\n                for (var _i = 0, _a = Object.keys(_this.ctab.current.equTab); _i < _a.length; _i++) {\n                    var key = _a[_i];\n                    if (split.args.match(key) === null) {\n                        continue;\n                    }\n                    for (var s = _this.ctab.current.equTab[key]; s !== undefined; s = _this.ctab.current.equTab[s]) {\n                        split.args = split.args.replace(key, _this.ctab.current.equTab[key]);\n                    }\n                    break;\n                }\n                if (split.tag !== \"\") {\n                    if (_this.ctab.current.tagTab[split.tag] !== undefined) {\n                        throw new Error(\"Duplicate label \" + split.tag);\n                    }\n                    _this.ctab.current.tagTab[split.tag] = _this.ctab.current.useTab.rloc;\n                }\n                if (_this.ctab.isDirective(split.op)) {\n                    _this.ctab.directives[split.op](val, split);\n                    return;\n                }\n                if (SicFormat1_1.SicFormat1.isFormat1(split.op)) {\n                    instr = new SicFormat1_1.SicFormat1(split);\n                }\n                else if (SicFormat2_1.SicFormat2.isFormat2(split.op)) {\n                    instr = new SicFormat2_1.SicFormat2(split);\n                }\n                else if (SicFormat3_1.SicFormat3.isFormat3(split.op)) {\n                    instr = new SicFormat3_1.SicFormat3(split, _this.ctab.current);\n                }\n                else if (SicFormat4_1.SicFormat4.isFormat4(split.op)) {\n                    instr = new SicFormat4_1.SicFormat4(split, _this.ctab.current);\n                }\n                else if (SicFormatLegacy_1.SicFormatLegacy.isFormatLegacy(split.op)) {\n                    instr = new SicFormatLegacy_1.SicFormatLegacy(split, _this.ctab.current);\n                }\n                else if (SicSpace_1.SicSpace.isSpace(split.op)) {\n                    instr = new SicSpace_1.SicSpace(split);\n                }\n                else {\n                    throw new Error(split.op + \" is not a valid mnemonic.\");\n                }\n                _this.ctab.addLst(new SicLstEntry_1.SicLstEntry(split.tag, val, { loc: _this.ctab.current.useTab.loc(), inst: instr }));\n                _this.ctab.current.useTab.inc(instr.length());\n            }\n            catch (e) {\n                _this.errflag = true;\n                _this.ctab.addLst(new SicLstEntry_1.SicLstEntry(\"\", val, e.message));\n            }\n        });\n        this.ctab.forEach(function (p) {\n            if (p.litTab.hasPending()) {\n                _this.ctab.directives[\"SILENT_LTORG\"](\"\", new SicSplit_1.SicSplit(\"\\tSILENT_LTORG\"));\n            }\n            p.useTab.correct();\n            p.lst.forEach(function (l) {\n                if (l.tag !== \"\" && l.bcData !== undefined) {\n                    p.tagTab[l.tag] = l.bcData.loc.r;\n                }\n            });\n        });\n        this.ctab.forEach(function (p) {\n            p.lst.forEach(function (l) {\n                if (l.bcData !== undefined && l.bcData.inst !== undefined && !l.bcData.inst.ready()) {\n                    try {\n                        var res = l.bcData.inst.makeReady(l.bcData.loc.r, p.tagTab, p.litTab, p.extRefTab);\n                        if (res !== null) {\n                            p.modRecs.push({ loc: l.bcData.loc.r, len: 5, symbol: res });\n                        }\n                    }\n                    catch (e) {\n                        var str = e.message;\n                        l.bcData = undefined;\n                        l.errmsg = str;\n                    }\n                }\n            });\n        });\n    }\n    SicCompiler.prototype.makeLst = function () {\n        return this.ctab.makeLst();\n    };\n    SicCompiler.prototype.makeObj = function () {\n        return this.ctab.makeObj();\n    };\n    Object.defineProperty(SicCompiler.prototype, \"err\", {\n        get: function () {\n            return this.errflag;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return SicCompiler;\n}());\nexports.SicCompiler = SicCompiler;","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SicBase_1 = require(\"./SicBase\");\nvar SicFmt_1 = require(\"./SicFmt\");\nvar SicLiteral_1 = require(\"./SicLiteral\");\nvar SicLitTab_1 = require(\"./SicLitTab\");\nvar SicLstEntry_1 = require(\"./SicLstEntry\");\nvar SicPending_1 = require(\"./SicPending\");\nvar SicSplit_1 = require(\"./SicSplit\");\nvar SicUseTab_1 = require(\"./SicUseTab\");\nvar SicCsect = (function () {\n    function SicCsect(startAddr) {\n        this.lst = [];\n        this.litTab = new SicLitTab_1.SicLitTab();\n        this.tagTab = {};\n        this.equTab = {};\n        this.useTab = new SicUseTab_1.SicUseTab(startAddr);\n        this.extDefTab = new Set();\n        this.extRefTab = new Set();\n        this.modRecs = [];\n    }\n    SicCsect.prototype.setStartAddr = function (startAddr) {\n        this.useTab = new SicUseTab_1.SicUseTab(startAddr);\n    };\n    SicCsect.prototype.objcodeArr = function () {\n        var m = this.lst.filter(function (q) { return q.bcData !== undefined && q.bcData.inst !== undefined; });\n        m.sort(function (a, b) {\n            var c = a.bcData;\n            var d = b.bcData;\n            return c.loc.r - d.loc.r;\n        });\n        return m.map(function (q) {\n            var r = q.bcData;\n            return { r: r.loc.r, o: r.inst.toBytes() };\n        });\n    };\n    SicCsect.prototype.objcodeLen = function () {\n        return this.useTab.loc().r;\n    };\n    return SicCsect;\n}());\nexports.SicCsect = SicCsect;\nvar SicCsectTab = (function () {\n    function SicCsectTab() {\n        var _this = this;\n        this.currentSect = \"\";\n        this.csects = {};\n        this.csects[this.currentSect] = new SicCsect(0);\n        this.lst = [];\n        var parseNum = function (val) {\n            var reDec = new RegExp(\"^(\\\\d+)$\");\n            var reHex = new RegExp(\"^X'([0-9A-Fa-f]+)'$\");\n            var reChar = new RegExp(\"^C'.{1,3}'$\");\n            var match;\n            if ((match = val.match(reDec)) !== null) {\n                return parseInt(match[1], 10);\n            }\n            if ((match = val.match(reHex)) !== null) {\n                return parseInt(match[1], 16);\n            }\n            if ((match = val.match(reChar)) !== null) {\n                var x = 0;\n                for (var ptr = 0, s = match[1]; s !== \"\"; ptr += 8, s = s.slice(0, -1)) {\n                    x += s.charCodeAt(s.length - 1) << ptr;\n                }\n                return x;\n            }\n            throw new Error(val + \" was not of a valid numeric format.\");\n        };\n        this.directives = {\n            RESW: function (source, split) {\n                _this.addLst(new SicLstEntry_1.SicLstEntry(split.tag, source, { loc: _this.current.useTab.loc(), inst: undefined }));\n                _this.current.useTab.inc(3 * parseNum(split.args));\n            },\n            RESB: function (source, split) {\n                _this.addLst(new SicLstEntry_1.SicLstEntry(split.tag, source, { loc: _this.current.useTab.loc(), inst: undefined }));\n                _this.current.useTab.inc(parseNum(split.args));\n            },\n            START: function (source, split) {\n                if (_this.currentSect !== \"\" || _this.current.lst.length !== 0) {\n                    throw new Error(\"START can only be used as the first line of a program.\");\n                }\n                _this.current.setStartAddr(parseInt(split.args, 16));\n                _this.addLst(new SicLstEntry_1.SicLstEntry(split.tag, source, { loc: _this.current.useTab.loc(), inst: undefined }));\n                _this.startData = { name: split.tag, loc: _this.current.useTab.aloc };\n            },\n            END: function (source, split) {\n                var cs;\n                if (split.args === \"\") {\n                    cs = \"\";\n                }\n                else if (_this.startData !== undefined && _this.startData.name === split.args) {\n                    cs = \"\";\n                }\n                else if (_this.csects[split.args] === undefined) {\n                    throw new Error(split.args + \" does not correspond to any given CSECT/START label.\");\n                }\n                else {\n                    cs = split.args;\n                }\n                _this.csect(cs);\n                if (_this.current.litTab.hasPending()) {\n                    _this.directives[\"SILENT_LTORG\"](\"\", new SicSplit_1.SicSplit(\"\\tSILENT_LTORG\"));\n                }\n                _this.current.useTab.correct();\n                _this.addLst(new SicLstEntry_1.SicLstEntry(split.tag, source, { loc: _this.current.useTab.loc(), inst: undefined }));\n            },\n            BASE: function (source, split) {\n                try {\n                    _this.current.base = new SicBase_1.SicBase(parseNum(split.args));\n                }\n                catch (e) {\n                    _this.current.base = new SicBase_1.SicBase(new SicPending_1.SicPending(split.args));\n                }\n                _this.addLst(new SicLstEntry_1.SicLstEntry(\"\", source));\n            },\n            NOBASE: function (source, split) {\n                _this.current.base = undefined;\n                _this.addLst(new SicLstEntry_1.SicLstEntry(\"\", source));\n            },\n            SILENT_LTORG: function (source, split) {\n                var l = _this.current.litTab.createOrg(_this.current.useTab.aloc);\n                l.forEach(function (v) {\n                    _this.addLst(new SicLstEntry_1.SicLstEntry(\"\", \"X'\" + SicFmt_1.asHex(v.val) + \"' BYTE X'\" + SicFmt_1.asHex(v.val) + \"'\", { loc: _this.current.useTab.loc(), inst: new SicLiteral_1.SicLiteral(v.val) }));\n                    _this.current.useTab.inc(3);\n                });\n            },\n            LTORG: function (source, split) {\n                _this.addLst(new SicLstEntry_1.SicLstEntry(\"\", source));\n                var l = _this.current.litTab.createOrg(_this.current.useTab.aloc);\n                l.forEach(function (v) {\n                    _this.addLst(new SicLstEntry_1.SicLstEntry(\"\", \"X'\" + SicFmt_1.asHex(v.val) + \"' BYTE X'\" + SicFmt_1.asHex(v.val) + \"'\", { loc: _this.current.useTab.loc(), inst: new SicLiteral_1.SicLiteral(v.val) }));\n                    _this.current.useTab.inc(3);\n                });\n            },\n            EQU: function (source, split) {\n                if (split.tag === \"\") {\n                    throw new Error(\"EQU needs a non-empty label.\");\n                }\n                if (_this.current.equTab[split.args] !== undefined) {\n                    throw new Error(\"EQU \" + split.args + \" was already defined.\");\n                }\n                _this.current.equTab[split.tag] = split.args;\n                _this.addLst(new SicLstEntry_1.SicLstEntry(\"\", source));\n            },\n            USE: function (source, split) {\n                _this.current.useTab.use(split.args);\n                _this.addLst(new SicLstEntry_1.SicLstEntry(\"\", source, { loc: _this.current.useTab.loc(), inst: undefined }));\n            },\n            CSECT: function (source, split) {\n                _this.addLst(new SicLstEntry_1.SicLstEntry(\"\", source));\n                _this.csect(split.tag);\n            },\n            EXTDEF: function (source, split) {\n                var s = split.args.split(\",\");\n                _this.addLst(new SicLstEntry_1.SicLstEntry(\"\", source));\n                s.forEach(function (r) { return _this.current.extDefTab.add(r); });\n            },\n            EXTREF: function (source, split) {\n                var s = split.args.split(\",\");\n                _this.addLst(new SicLstEntry_1.SicLstEntry(\"\", source));\n                s.forEach(function (r) {\n                    if (_this.current.extRefTab.has(r)) {\n                        throw new Error(\"Duplicate EXTREF \" + r);\n                    }\n                    if (_this.current.tagTab[r] !== undefined) {\n                        throw new Error(\"Duplicate label \" + r);\n                    }\n                    _this.current.extRefTab.add(r);\n                });\n            },\n        };\n    }\n    SicCsectTab.prototype.litPool = function () {\n        var _this = this;\n        var l = this.current.litTab.createOrg(this.current.useTab.aloc);\n        l.forEach(function (v) {\n            _this.addLst(new SicLstEntry_1.SicLstEntry(\"\", \"X'\" + SicFmt_1.asHex(v.val) + \"' BYTE X'\" + SicFmt_1.asHex(v.val) + \"'\", { loc: _this.current.useTab.loc(), inst: new SicLiteral_1.SicLiteral(v.val) }));\n            _this.current.useTab.inc(3);\n        });\n    };\n    SicCsectTab.prototype.isDirective = function (mnemonic) {\n        if (mnemonic === \"SILENT_LTORG\") {\n            return false;\n        }\n        return this.directives[mnemonic] !== undefined;\n    };\n    SicCsectTab.prototype.addLst = function (l) {\n        this.lst.push(l);\n        this.current.lst.push(l);\n    };\n    SicCsectTab.prototype.makeLst = function () {\n        var s = [\"n\"];\n        s[0] = \"n    \\taloc \\trloc \\tbytecode\\tsource\";\n        s[1] = \"-----\\t-----\\t-----\\t--------\\t------\";\n        var i = 1;\n        return s.concat(this.lst.map(function (ls) {\n            var astr = ls.bcData === undefined ? \"\" : SicFmt_1.asHex(ls.bcData.loc.a);\n            var rstr = ls.bcData === undefined ? \"\" : SicFmt_1.asHex(ls.bcData.loc.r);\n            var inststr = ls.hasInstruction() ? ls.byteString() : \"\";\n            var istr = i.toString(10);\n            ++i;\n            var msg = istr.padEnd(5, \" \") + \"\\t\" +\n                astr.padEnd(5, \" \") + \"\\t\" +\n                rstr.padEnd(5, \" \") + \"\\t\" +\n                inststr.padEnd(8, \" \") + \"\\t\" +\n                ls.source;\n            if (ls.errmsg !== undefined) {\n                msg += \"\\n* Error: \" + ls.errmsg + \" *\";\n            }\n            return msg;\n        }));\n    };\n    SicCsectTab.prototype.makeObj = function () {\n        var s = [];\n        var mkH = function (len, loc, name) {\n            if (loc === undefined) {\n                loc = 0;\n            }\n            if (name === undefined) {\n                name = \"\";\n            }\n            return \"H\" + name + \" \" + SicFmt_1.asWord(loc) + \" \" + SicFmt_1.asWord(len);\n        };\n        var mkD = function (defs, tagTab) {\n            if (defs.size === 0) {\n                return \"\";\n            }\n            var a = \"D \";\n            defs.forEach(function (v) { return a += v + \" \" + SicFmt_1.asWord(tagTab[v]); }, \"\");\n            return a;\n        };\n        var mkR = function (refs) {\n            if (refs.size === 0) {\n                return \"\";\n            }\n            var a = \"R \";\n            refs.forEach(function (v) { return a += v + \" \"; }, \"\");\n            return a.trim();\n        };\n        var mkT = function (arr) {\n            var buf = [];\n            arr.forEach(function (l) {\n                buf.push(\"T \" + SicFmt_1.asWord(l.r) + \" \" + SicFmt_1.asByte(l.o.length) + \" \" + SicFmt_1.bytesToString(l.o));\n            });\n            return buf;\n        };\n        var mkE = function (loc) {\n            if (loc === undefined) {\n                return \"E\";\n            }\n            return \"E \" + SicFmt_1.asWord(loc);\n        };\n        var mkM = function (modrec) {\n            return modrec.map(function (m) {\n                return \"M \" + SicFmt_1.asWord(m.loc) + \" \" + SicFmt_1.asByte(m.len) + \" +\" + m.symbol;\n            });\n        };\n        var sloc = this.startData !== undefined ? this.startData.loc : 0;\n        var sname = this.startData !== undefined ? this.startData.name : \"\";\n        var ss = this.csects[\"\"].objcodeArr();\n        s.push(mkH(this.csects[\"\"].objcodeLen(), sloc, sname));\n        s.push(mkD(this.csects[\"\"].extDefTab, this.csects[\"\"].tagTab));\n        s.push(mkR(this.csects[\"\"].extRefTab));\n        s = s.concat(mkT(ss));\n        s = s.concat(mkM(this.csects[\"\"].modRecs));\n        s.push(mkE(sloc));\n        this.forEachAux(function (c, n) {\n            var sss = c.objcodeArr();\n            s.push(mkH(c.objcodeLen(), 0, n));\n            s.push(mkD(c.extDefTab, c.tagTab));\n            s.push(mkR(c.extRefTab));\n            s = s.concat(mkT(sss));\n            s = s.concat(mkM(c.modRecs));\n            s.push(mkE());\n        });\n        return s.filter(function (r) { return r !== \"\"; });\n    };\n    Object.defineProperty(SicCsectTab.prototype, \"current\", {\n        get: function () {\n            return this.csects[this.currentSect];\n        },\n        enumerable: true,\n        configurable: true\n    });\n    SicCsectTab.prototype.csect = function (newSect) {\n        this.currentSect = newSect;\n        if (this.csects[this.currentSect] === undefined) {\n            this.csects[this.currentSect] = new SicCsect(0);\n        }\n    };\n    Object.defineProperty(SicCsectTab.prototype, \"default\", {\n        get: function () {\n            return this.csects[\"\"];\n        },\n        enumerable: true,\n        configurable: true\n    });\n    SicCsectTab.prototype.forEach = function (callback) {\n        var _this = this;\n        var curBuf = this.currentSect;\n        Object.keys(this.csects).forEach(function (c) {\n            _this.currentSect = c;\n            callback(_this.csects[c], c);\n        });\n        this.currentSect = curBuf;\n    };\n    SicCsectTab.prototype.forEachAux = function (callback) {\n        var _this = this;\n        var curBuf = this.currentSect;\n        Object.keys(this.csects).forEach(function (c) {\n            if (c === \"\") {\n                return;\n            }\n            _this.currentSect = c;\n            callback(_this.csects[c], c);\n        });\n        this.currentSect = curBuf;\n    };\n    return SicCsectTab;\n}());\nexports.SicCsectTab = SicCsectTab;","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.asHex = function (n) { return n.toString(16).toUpperCase(); };\nexports.asWord = function (n) { return exports.asHex(n).padStart(6, \"0\"); };\nexports.asByte = function (n) { return exports.asHex(n).padStart(2, \"0\"); };\nexports.bytesToString = function (n) { return n.reduce(function (acc, val) { return acc + exports.asByte(val); }, \"\"); };","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SicBytecode_1 = require(\"./SicBytecode\");\nvar SicFormat1 = (function () {\n    function SicFormat1(line) {\n        if (!SicFormat1.isFormat1(line.op)) {\n            throw new Error(line.op + \" is not a format 1 operation\");\n        }\n        if (line.args !== \"\") {\n            throw new Error(\"Format 1 arguments cannot have arguments\");\n        }\n        this.bc = SicBytecode_1.bytecodeTable[line.op];\n    }\n    SicFormat1.isFormat1 = function (mnemonic) {\n        var bc = SicBytecode_1.bytecodeTable[mnemonic];\n        return bc !== undefined && bc.format === 1;\n    };\n    SicFormat1.prototype.ready = function () {\n        return true;\n    };\n    SicFormat1.prototype.makeReady = function (loc, tagTab, litTab, extRefTab) {\n        return null;\n    };\n    SicFormat1.prototype.length = function () {\n        return 1;\n    };\n    SicFormat1.prototype.toBytes = function () {\n        return [this.bc.opcode];\n    };\n    return SicFormat1;\n}());\nexports.SicFormat1 = SicFormat1;","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SicBytecode_1 = require(\"./SicBytecode\");\nvar SicRegConvert_1 = require(\"./SicRegConvert\");\nvar SicUnsigned_1 = require(\"./SicUnsigned\");\nvar SicFormat2 = (function () {\n    function SicFormat2(line) {\n        if (!SicFormat2.isFormat2(line.op)) {\n            throw new Error(line.op + \" is not a format 2 opcode\");\n        }\n        this.bc = SicBytecode_1.bytecodeTable[line.op];\n        var s = line.args.trim().split(/\\s*,\\s*/);\n        if (s.length === 1) {\n            s.push(\"0\");\n        }\n        if (s.length !== 2) {\n            throw new Error(\"This format 2 instruction has an invalid number of operands.\");\n        }\n        var matcher = function (str) {\n            var reRegister = new RegExp(\"^(A|X|L|PC|SW|B|S|T|F)$\");\n            var reHex = new RegExp(\"^X'([0-9A-Fa-f]+)'$\");\n            var reDec = new RegExp(\"^([0-9]+)$\");\n            var match;\n            if ((match = str.match(reRegister)) !== null) {\n                return SicRegConvert_1.sicRegToDec(match[1]);\n            }\n            else if ((match = str.match(reHex)) !== null) {\n                return parseInt(match[1], 16);\n            }\n            else if ((match = str.match(reDec)) !== null) {\n                return parseInt(match[1], 10);\n            }\n            throw new Error(str + \" is not a valid format 2 operand.\");\n        };\n        this.op1 = matcher(s[0]);\n        SicUnsigned_1.sicCheckUnsigned(this.op1, 4);\n        this.op2 = matcher(s[1]);\n        SicUnsigned_1.sicCheckUnsigned(this.op2, 4);\n    }\n    SicFormat2.isFormat2 = function (mnemonic) {\n        var bc = SicBytecode_1.bytecodeTable[mnemonic];\n        return bc !== undefined && bc.format === 2;\n    };\n    SicFormat2.prototype.ready = function () {\n        return true;\n    };\n    SicFormat2.prototype.makeReady = function (loc, tagTab, litTab, extRefTab) {\n        return null;\n    };\n    SicFormat2.prototype.length = function () {\n        return 2;\n    };\n    SicFormat2.prototype.toBytes = function () {\n        var bytes = [0x00, 0x00];\n        bytes[0] = this.bc.opcode;\n        bytes[1] |= (this.op1 & 0x0F) << 4;\n        bytes[1] |= (this.op2 & 0x0F);\n        return bytes;\n    };\n    return SicFormat2;\n}());\nexports.SicFormat2 = SicFormat2;","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SicBytecode_1 = require(\"./SicBytecode\");\nvar SicOperandAddr_1 = require(\"./SicOperandAddr\");\nvar SicFormat3 = (function () {\n    function SicFormat3(line, csect) {\n        if (!SicFormat3.isFormat3(line.op)) {\n            throw new Error(line.op + \" is not format 3\");\n        }\n        this.bc = SicBytecode_1.bytecodeTable[line.op];\n        this.op = new SicOperandAddr_1.SicOperandAddr(line.args, SicOperandAddr_1.SicOpType.f3, csect);\n    }\n    SicFormat3.isFormat3 = function (mnemonic) {\n        var bc = SicBytecode_1.bytecodeTable[mnemonic];\n        return bc !== undefined && bc.format === 3;\n    };\n    SicFormat3.prototype.makeReady = function (loc, tagTab, litTab, extRefTab) {\n        return this.op.makeReady(loc + this.length(), tagTab, litTab, extRefTab);\n    };\n    SicFormat3.prototype.ready = function () {\n        return this.op.ready();\n    };\n    SicFormat3.prototype.length = function () {\n        return 3;\n    };\n    SicFormat3.prototype.toBytes = function () {\n        if (!this.ready()) {\n            throw new Error(\"Internal error: This SicFormat3 instruction is not ready.\");\n        }\n        var bytes = this.op.nixbpe();\n        bytes[0] |= (this.bc.opcode & 0xFC);\n        bytes[1] |= (this.op.val & 0x0F00) >>> 8;\n        bytes[2] = (this.op.val & 0xFF);\n        return bytes;\n    };\n    return SicFormat3;\n}());\nexports.SicFormat3 = SicFormat3;","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SicBytecode_1 = require(\"./SicBytecode\");\nvar SicOperandAddr_1 = require(\"./SicOperandAddr\");\nvar SicFormat4 = (function () {\n    function SicFormat4(line, csect) {\n        if (!SicFormat4.isFormat4(line.op)) {\n            throw new Error(line.op + \" is not format 4\");\n        }\n        this.bc = SicBytecode_1.bytecodeTable[line.op.slice(1)];\n        this.op = new SicOperandAddr_1.SicOperandAddr(line.args, SicOperandAddr_1.SicOpType.f4, csect);\n    }\n    SicFormat4.isFormat4 = function (mnemonic) {\n        if (mnemonic.charAt(0) !== \"+\") {\n            return false;\n        }\n        var bc = SicBytecode_1.bytecodeTable[mnemonic.slice(1)];\n        return bc !== undefined && bc.format === 3;\n    };\n    SicFormat4.prototype.makeReady = function (loc, tagTab, litTab, extRefTab) {\n        return this.op.makeReady(loc + this.length(), tagTab, litTab, extRefTab);\n    };\n    SicFormat4.prototype.ready = function () {\n        return this.op.ready();\n    };\n    SicFormat4.prototype.length = function () {\n        return 4;\n    };\n    SicFormat4.prototype.toBytes = function () {\n        if (!this.ready()) {\n            throw new Error(\"Internal error: This SicFormat4 instruction is not ready.\");\n        }\n        var bytes = this.op.nixbpe();\n        bytes[0] |= (this.bc.opcode & 0xFC);\n        bytes[1] |= (this.op.val & 0x0F0000) >>> 16;\n        bytes[2] = (this.op.val & 0xFF00) >>> 8;\n        bytes[3] = (this.op.val & 0xFF);\n        return bytes;\n    };\n    return SicFormat4;\n}());\nexports.SicFormat4 = SicFormat4;","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SicBytecode_1 = require(\"./SicBytecode\");\nvar SicOperandAddr_1 = require(\"./SicOperandAddr\");\nvar SicFormatLegacy = (function () {\n    function SicFormatLegacy(line, csect) {\n        if (!SicFormatLegacy.isFormatLegacy(line.op)) {\n            throw new Error(line.op + \" is not SIC legacy format\");\n        }\n        this.bc = SicBytecode_1.bytecodeTable[line.op.slice(1)];\n        this.op = new SicOperandAddr_1.SicOperandAddr(line.args, SicOperandAddr_1.SicOpType.legacy, csect);\n    }\n    SicFormatLegacy.isFormatLegacy = function (mnemonic) {\n        if (mnemonic.charAt(0) !== \"*\") {\n            return false;\n        }\n        var bc = SicBytecode_1.bytecodeTable[mnemonic.slice(1)];\n        return bc !== undefined && bc.format === 3;\n    };\n    SicFormatLegacy.prototype.makeReady = function (loc, tagTab, litTab, extRefTab) {\n        return this.op.makeReady(loc + this.length(), tagTab, litTab, extRefTab);\n    };\n    SicFormatLegacy.prototype.ready = function () {\n        return this.op.ready();\n    };\n    SicFormatLegacy.prototype.length = function () {\n        return 3;\n    };\n    SicFormatLegacy.prototype.toBytes = function () {\n        if (!this.ready()) {\n            throw new Error(\"Internal error: This SicFormatLegacy instruction is not ready.\");\n        }\n        var bytes = this.op.nixbpe();\n        bytes[0] |= (this.bc.opcode & 0xFC);\n        bytes[1] |= (this.op.val & 0x7F00) >>> 8;\n        bytes[2] = (this.op.val & 0xFF);\n        return bytes;\n    };\n    return SicFormatLegacy;\n}());\nexports.SicFormatLegacy = SicFormatLegacy;","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SicLitTab = (function () {\n    function SicLitTab() {\n        this.ltorgs = [];\n        this.pending = new Set();\n    }\n    SicLitTab.prototype.getLitLoc = function (n, pc) {\n        if (pc === void 0) { pc = 0; }\n        var diffMin = Number.MAX_SAFE_INTEGER;\n        var loc = null;\n        this.ltorgs.forEach(function (lt) {\n            if (lt.val === n && diffMin > Math.min(lt.loc - pc, lt.loc)) {\n                diffMin = Math.min(lt.loc - pc, lt.loc);\n                loc = lt.loc;\n            }\n        });\n        return loc;\n    };\n    SicLitTab.prototype.createOrg = function (loc) {\n        var l = loc;\n        var m = [];\n        var lt = this.pending.forEach(function (v) {\n            m.push({ loc: l, val: v });\n            l += 3;\n        });\n        this.ltorgs = this.ltorgs.concat(m);\n        this.pending = new Set();\n        return m;\n    };\n    SicLitTab.prototype.add = function (n) {\n        if (this.getLitLoc(n) === null) {\n            this.pending.add(n);\n        }\n    };\n    SicLitTab.prototype.hasPending = function (n) {\n        if (n === undefined) {\n            return this.pending.size > 0;\n        }\n        return this.pending.has(n);\n    };\n    return SicLitTab;\n}());\nexports.SicLitTab = SicLitTab;","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SicSpace_1 = require(\"./SicSpace\");\nvar SicLiteral = (function () {\n    function SicLiteral(val) {\n        this.val = val;\n    }\n    SicLiteral.prototype.length = function () {\n        return 3;\n    };\n    SicLiteral.prototype.ready = function () {\n        return true;\n    };\n    SicLiteral.prototype.makeReady = function (loc, tagTab, litTab, extRefTab) {\n        return null;\n    };\n    SicLiteral.prototype.toBytes = function () {\n        return SicSpace_1.SicSpace.splitWord(this.val);\n    };\n    return SicLiteral;\n}());\nexports.SicLiteral = SicLiteral;","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SicFmt_1 = require(\"./SicFmt\");\nvar SicLstEntry = (function () {\n    function SicLstEntry(tag, source, bcData) {\n        this.tag = tag;\n        this.source = source;\n        if (typeof bcData === \"string\") {\n            this.bcData = undefined;\n            this.errmsg = bcData;\n        }\n        else {\n            this.bcData = bcData;\n            this.errmsg = undefined;\n        }\n    }\n    SicLstEntry.prototype.hasInstruction = function () {\n        return this.bcData !== undefined && this.bcData.inst !== undefined;\n    };\n    SicLstEntry.prototype.byteCode = function () {\n        if (!(this.bcData !== undefined && this.bcData.inst !== undefined)) {\n            throw new Error(\"This SicLstEntry does not have an instruction in it\");\n        }\n        return this.bcData.inst.toBytes();\n    };\n    SicLstEntry.prototype.byteString = function () {\n        return SicFmt_1.bytesToString(this.byteCode());\n    };\n    return SicLstEntry;\n}());\nexports.SicLstEntry = SicLstEntry;","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SicPending_1 = require(\"./SicPending\");\nvar SicUnsigned_1 = require(\"./SicUnsigned\");\nvar SicOpAddrType;\n(function (SicOpAddrType) {\n    SicOpAddrType[SicOpAddrType[\"immediate\"] = 0] = \"immediate\";\n    SicOpAddrType[SicOpAddrType[\"direct\"] = 1] = \"direct\";\n    SicOpAddrType[SicOpAddrType[\"indirect\"] = 2] = \"indirect\";\n})(SicOpAddrType = exports.SicOpAddrType || (exports.SicOpAddrType = {}));\nvar SicOpType;\n(function (SicOpType) {\n    SicOpType[SicOpType[\"f3\"] = 0] = \"f3\";\n    SicOpType[SicOpType[\"f4\"] = 1] = \"f4\";\n    SicOpType[SicOpType[\"legacy\"] = 2] = \"legacy\";\n})(SicOpType = exports.SicOpType || (exports.SicOpType = {}));\nvar SicOperandAddr = (function () {\n    function SicOperandAddr(arg, type, csect) {\n        var reDecimal = new RegExp(\"^(=|#|@)?(-?\\\\d+)(,X)?$\");\n        var reHex = new RegExp(\"^(=|#|@)?X'([0-9A-F]+)'(,X)?$\");\n        var reChar = new RegExp(\"^(=|#|@)?C'(.{1,3})'(,X)?$\");\n        var reTag = new RegExp(\"^(#|@)?([A-Z0-9]+)(,X)?$\");\n        var getType = function (char) {\n            switch (char) {\n                case \"#\":\n                    return SicOpAddrType.immediate;\n                case \"@\":\n                    return SicOpAddrType.indirect;\n                case \"=\":\n                default:\n                    return SicOpAddrType.direct;\n            }\n        };\n        var isLiteral = function (c) { return c !== undefined && c.charAt(0) === \"=\"; };\n        this.type = type;\n        this.base = this.type === SicOpType.f3 ? csect.base : undefined;\n        this.pcrel = this.type === SicOpType.f3;\n        var match;\n        if ((match = arg.match(reDecimal)) !== null) {\n            var x = parseInt(match[2], 10);\n            if (isLiteral(match[1])) {\n                csect.litTab.add(x);\n                this.val = new SicPending_1.SicPending(x);\n            }\n            else {\n                this.val = x;\n                this.pcrel = false;\n                this.base = undefined;\n            }\n        }\n        else if ((match = arg.match(reHex)) !== null) {\n            var x = parseInt(match[2], 16);\n            if (isLiteral(match[1])) {\n                csect.litTab.add(x);\n                this.val = new SicPending_1.SicPending(x);\n            }\n            else {\n                this.val = x;\n                this.pcrel = false;\n                this.base = undefined;\n            }\n        }\n        else if ((match = arg.match(reChar)) !== null) {\n            var bytes = [];\n            for (var i = 0; i < match[2].length; ++i) {\n                bytes.push(match[2].charCodeAt(i));\n            }\n            while (bytes.length < 3) {\n                bytes = [0].concat(bytes);\n            }\n            var x = (bytes[0] << 16) + (bytes[1] << 8) + (bytes[2]);\n            if (isLiteral(match[1])) {\n                csect.litTab.add(x);\n                this.val = new SicPending_1.SicPending(x);\n            }\n            else {\n                this.val = x;\n                this.pcrel = false;\n                this.base = undefined;\n            }\n        }\n        else if ((match = arg.match(reTag)) != null) {\n            if (csect.extRefTab.has(match[2])) {\n                if (this.type !== SicOpType.f4) {\n                    throw new Error(\"EXTREF symbols can only be used with format 4\");\n                }\n                csect.modRecs.push({ loc: csect.useTab.aloc, len: 5, symbol: match[2] });\n                this.val = 0;\n                this.pcrel = false;\n            }\n            else {\n                this.val = new SicPending_1.SicPending(match[2]);\n            }\n        }\n        else if (arg.trim() === \"\") {\n            this.val = 0;\n            this.pcrel = false;\n            this.base = undefined;\n            this.addr = SicOpAddrType.direct;\n            this.indexed = false;\n            this.rdy = true;\n            return;\n        }\n        else {\n            throw new Error(\"Operand \" + arg + \" is not of any valid format.\");\n        }\n        this.addr = getType(match[1]);\n        this.indexed = match[3] != null;\n        if (this.addr !== SicOpAddrType.direct && this.type === SicOpType.legacy) {\n            throw new Error(\"SIC Legacy instructions can only use direct addressing\");\n        }\n        this.rdy = !this.pcrel &&\n            this.base === undefined &&\n            typeof this.val === \"number\";\n    }\n    SicOperandAddr.prototype.ready = function () {\n        return this.rdy;\n    };\n    SicOperandAddr.prototype.makeReady = function (pc, tagTab, litTab, extRefTab) {\n        if (this.rdy) {\n            return null;\n        }\n        if (this.base !== undefined && !this.base.ready()) {\n            this.base.makeReady(tagTab);\n        }\n        if (typeof this.val !== \"number\") {\n            var q = this.val.convert(tagTab, litTab, extRefTab);\n            if (typeof q === \"string\") {\n                this.val = 0;\n                if (this.type !== SicOpType.f4) {\n                    throw new Error(\"EXTREF'd symbols can only be used with pass 2\");\n                }\n                return q;\n            }\n            this.val = q;\n        }\n        var opLen;\n        switch (this.type) {\n            case SicOpType.f3:\n                opLen = 12;\n                break;\n            case SicOpType.legacy:\n                opLen = 15;\n                break;\n            case SicOpType.f4:\n                opLen = 20;\n                break;\n            default:\n                throw new Error(\"type is not valid\");\n        }\n        if (this.pcrel) {\n            try {\n                this.val = SicUnsigned_1.sicMakeUnsigned(this.val - pc, opLen);\n                this.rdy = true;\n                return null;\n            }\n            catch (e) {\n                this.pcrel = false;\n            }\n        }\n        if (this.base) {\n            try {\n                this.val = SicUnsigned_1.sicMakeUnsigned(this.val - this.base.val, opLen);\n                this.rdy = true;\n                return null;\n            }\n            catch (e) {\n                this.base = undefined;\n            }\n        }\n        SicUnsigned_1.sicCheckUnsigned(this.val, opLen);\n        this.rdy = true;\n        return null;\n    };\n    SicOperandAddr.prototype.nixbpe = function () {\n        if (!this.ready()) {\n            throw new Error(\"nixbpe() can only be called when the value is ready.\");\n        }\n        var n;\n        var i;\n        var x = this.indexed;\n        var b = !this.pcrel && this.base !== undefined;\n        var p = this.pcrel;\n        var e = this.type === SicOpType.f4;\n        switch (this.addr) {\n            case SicOpAddrType.direct:\n                if (this.type === SicOpType.legacy) {\n                    n = false;\n                    i = false;\n                }\n                else {\n                    n = true;\n                    i = true;\n                }\n                break;\n            case SicOpAddrType.indirect:\n                n = true;\n                i = false;\n                break;\n            case SicOpAddrType.immediate:\n                n = false;\n                i = true;\n                break;\n            default:\n                throw new Error(\"Registers do not have an nixbpe value\");\n        }\n        var bytes = [0x0, 0x0];\n        if (n) {\n            bytes[0] |= 0x2;\n        }\n        if (i) {\n            bytes[0] |= 0x1;\n        }\n        if (x) {\n            bytes[1] |= 0x80;\n        }\n        if (b) {\n            bytes[1] |= 0x40;\n        }\n        if (p) {\n            bytes[1] |= 0x20;\n        }\n        if (e) {\n            bytes[1] |= 0x10;\n        }\n        return bytes;\n    };\n    return SicOperandAddr;\n}());\nexports.SicOperandAddr = SicOperandAddr;","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SicPending = (function () {\n    function SicPending(val) {\n        this.val = val;\n    }\n    SicPending.prototype.isLiteral = function () {\n        return typeof this.val === \"number\";\n    };\n    SicPending.prototype.isTag = function () {\n        return typeof this.val === \"string\";\n    };\n    SicPending.prototype.convert = function (tagTab, litTab, extRefTab) {\n        var s;\n        if (typeof this.val === \"number\") {\n            if (litTab === null) {\n                throw new Error(\"litTab is undefined but this SicPending is a literal\");\n            }\n            s = litTab.getLitLoc(this.val);\n            if (s === null) {\n                throw new Error(this.val + \"was not found in the literal table\");\n            }\n            return s;\n        }\n        if (extRefTab !== null && extRefTab.has(this.val)) {\n            return this.val;\n        }\n        if (tagTab === null) {\n            throw new Error(\"tagTab is undefined but this SicPending is a tag\");\n        }\n        s = tagTab[this.val];\n        if (s === null) {\n            throw new Error(this.val + \"was not found in the tag table\");\n        }\n        return s;\n    };\n    return SicPending;\n}());\nexports.SicPending = SicPending;","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.sicRegToDec = function (reg) {\n    switch (reg) {\n        case \"A\":\n            return 0;\n        case \"X\":\n            return 1;\n        case \"L\":\n            return 2;\n        case \"B\":\n            return 3;\n        case \"S\":\n            return 4;\n        case \"T\":\n            return 5;\n        case \"F\":\n            return 6;\n        case \"PC\":\n            return 8;\n        case \"SW\":\n            return 9;\n        default:\n            throw new Error(\"reg type \" + reg + \" is not valid\");\n    }\n};\nexports.sicDecToReg = function (reg) {\n    switch (reg) {\n        case 0:\n            return \"A\";\n        case 1:\n            return \"X\";\n        case 2:\n            return \"L\";\n        case 3:\n            return \"B\";\n        case 4:\n            return \"S\";\n        case 5:\n            return \"T\";\n        case 6:\n            return \"F\";\n        case 8:\n            return \"PC\";\n        case 9:\n            return \"SW\";\n        default:\n            throw new Error(\"reg no \" + reg + \" is not valid\");\n    }\n};","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SicUnsigned_1 = require(\"./SicUnsigned\");\nvar SicSpace = (function () {\n    function SicSpace(line) {\n        if (!SicSpace.isSpace(line.op)) {\n            throw new Error(\"This mnemonic is not a space.\");\n        }\n        this.mnemonic = line.op;\n        var func = this.mnemonic === \"BYTE\" ? SicSpace.splitByte : SicSpace.splitWord;\n        var reDec = new RegExp(\"^(-?\\\\d+)$\");\n        var reHex = new RegExp(\"^X'([0-9A-Fa-f]+)'$\");\n        var reChar = new RegExp(\"^C'(.+)'$\");\n        var match;\n        if ((match = line.args.match(reDec)) !== null) {\n            this.arg = func(parseInt(match[1], 10));\n        }\n        else if ((match = line.args.match(reHex)) !== null) {\n            this.arg = func(parseInt(match[1], 16));\n        }\n        else if ((match = line.args.match(reChar)) !== null) {\n            this.arg = [];\n            for (var i = 0; i < match[1].length; ++i) {\n                this.arg.push(match[1].charCodeAt(i));\n            }\n        }\n        else {\n            throw new Error(line.args + \" is not a valid operand format.\");\n        }\n    }\n    SicSpace.isSpace = function (mnemonic) {\n        var re = new RegExp(\"^(WORD|BYTE)$\");\n        return re.test(mnemonic);\n    };\n    SicSpace.splitWord = function (n) {\n        if (n >= 0) {\n            SicUnsigned_1.sicCheckUnsigned(n, 24);\n        }\n        else {\n            n = SicUnsigned_1.sicMakeUnsigned(n, 24);\n        }\n        return [(n & 0xFF0000) >>> 16, (n & 0xFF00) >>> 8, (n & 0xFF)];\n    };\n    SicSpace.splitByte = function (n) {\n        if (n < 0) {\n            n = SicUnsigned_1.sicMakeUnsigned(n, 8);\n            return [n];\n        }\n        var arr = [];\n        while (n > 0) {\n            arr = [n & 0xFF].concat(arr);\n            n >>>= 8;\n        }\n        return arr;\n    };\n    SicSpace.prototype.ready = function () {\n        return true;\n    };\n    SicSpace.prototype.makeReady = function (loc, tagTab, litTab, extRefTab) {\n        return null;\n    };\n    SicSpace.prototype.length = function () {\n        switch (this.mnemonic) {\n            case \"WORD\":\n                return this.arg.length + (this.arg.length % 3 !== 0 ? 1 : 0);\n            case \"BYTE\":\n                return this.arg.length;\n            default:\n                throw new Error(this.mnemonic + \" is invalid. this is a ultra mega bug\");\n        }\n    };\n    SicSpace.prototype.toBytes = function () {\n        var a = [];\n        switch (this.mnemonic) {\n            case \"WORD\":\n                for (var i = 0; i < this.arg.length % 3; ++i) {\n                    a.push(0x00);\n                }\n                this.arg.forEach(function (val) { return a.push(val); });\n                return a;\n            case \"BYTE\":\n                return this.arg;\n            default:\n                throw new Error(\"Mnemonic is invalid.\");\n        }\n    };\n    return SicSpace;\n}());\nexports.SicSpace = SicSpace;","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SicSplit = (function () {\n    function SicSplit(line) {\n        line = line.replace(/\\..*$/, \"\").toUpperCase();\n        var lineArr = line.split(/\\s+/);\n        if (lineArr.length <= 1) {\n            throw new Error(\"This line does not have the correct number of entries. Did you forget to put whitespace before the operand?\");\n        }\n        this.tag = lineArr[0];\n        this.op = lineArr[1];\n        if (lineArr.length >= 3) {\n            this.args = lineArr.slice(2).reduce(function (acc, val) { return acc + val; }, \"\");\n        }\n        else {\n            this.args = \"\";\n        }\n        if (this.tag !== \"\" && this.tag.match(/^[A-Z][A-Z0-9]*$/) === null) {\n            throw new Error(\"Labels must start with A-Z (found \\\"\" + this.tag + \"\\\")\");\n        }\n    }\n    return SicSplit;\n}());\nexports.SicSplit = SicSplit;","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SicFmt_1 = require(\"./SicFmt\");\nexports.sicMakeMask = function (nBits) {\n    var m = 0x0;\n    for (var i = 0; i < nBits; ++i) {\n        m |= (1 << i);\n    }\n    return m;\n};\nexports.sicCheckUnsigned = function (val, nBits) {\n    if (val < 0x0 || val > exports.sicMakeMask(nBits)) {\n        throw new Error(SicFmt_1.asHex(val) + \" does not fit in an unsigned \" + nBits + \"-bit range\");\n    }\n};\nexports.sicMakeUnsigned = function (val, nBits) {\n    var m = exports.sicMakeMask(nBits - 1);\n    if (val < -m - 1 || val > m) {\n        throw new Error(SicFmt_1.asHex(val) + \" does not fit in a signed \" + nBits + \"-bit range\");\n    }\n    val >>>= 0;\n    val &= exports.sicMakeMask(nBits);\n    return val;\n};","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SicLocPair = (function () {\n    function SicLocPair(aloc, rloc) {\n        this.a = aloc;\n        this.r = rloc === undefined ? aloc : rloc;\n    }\n    return SicLocPair;\n}());\nexports.SicLocPair = SicLocPair;\nvar SicUseTab = (function () {\n    function SicUseTab(startloc) {\n        this.ALOC = startloc;\n        this.useTab = [{ label: \"\", rloc: startloc, locsent: [] }];\n        this.curIndex = 0;\n        this.curUse = \"\";\n    }\n    Object.defineProperty(SicUseTab.prototype, \"aloc\", {\n        get: function () {\n            return this.ALOC;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SicUseTab.prototype, \"rloc\", {\n        get: function () {\n            return this.current.rloc;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    SicUseTab.prototype.loc = function () {\n        if (this.finalPair !== undefined) {\n            return this.finalPair;\n        }\n        var l = new SicLocPair(this.ALOC, this.current.rloc);\n        this.current.locsent.push(l);\n        return l;\n    };\n    SicUseTab.prototype.inc = function (n) {\n        this.current.rloc += n;\n        this.ALOC += n;\n    };\n    SicUseTab.prototype.use = function (label) {\n        this.curUse = label;\n        var index = this.find(label);\n        if (index === null) {\n            this.useTab.push({ label: label, rloc: 0, locsent: [] });\n            this.curIndex = this.useTab.length - 1;\n        }\n        else {\n            this.curIndex = index;\n        }\n    };\n    SicUseTab.prototype.correct = function () {\n        if (this.finalPair !== undefined) {\n            return;\n        }\n        var prev = this.current.rloc;\n        for (var i = 1; i < this.useTab.length; ++i) {\n            this.useTab[i].locsent.forEach(function (l) { return l.r += prev; });\n            prev += this.useTab[i].rloc;\n        }\n        this.finalPair = new SicLocPair(this.aloc, prev);\n    };\n    SicUseTab.prototype.find = function (label) {\n        for (var i = 0; i < this.useTab.length; ++i) {\n            if (this.useTab[i].label === label) {\n                return i;\n            }\n        }\n        return null;\n    };\n    Object.defineProperty(SicUseTab.prototype, \"current\", {\n        get: function () {\n            return this.useTab[this.curIndex];\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return SicUseTab;\n}());\nexports.SicUseTab = SicUseTab;","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nrequire(\"jquery\");\nvar SicCompiler_1 = require(\"./SicCompiler/SicCompiler\");\nvar editor = ace.edit(\"editor\");\neditor.setTheme(\"ace/theme/monokai\");\neditor.session.setMode(\"ace/mode/sicxe\");\n$(\"#output\").val(\"\");\nvar textToArray = function (innerText) {\n    return innerText.split(\"\\n\");\n};\nvar arrayToText = function (array) {\n    return array.reduce(function (acc, val) { return acc + \"\\n\" + val; });\n};\n$(\"#btnCompile\").click(function () {\n    try {\n        var arr = textToArray(editor.getValue());\n        var comp = new SicCompiler_1.SicCompiler(arr);\n        var output = [\"-----lst-----\"];\n        output = output.concat(comp.makeLst());\n        if (!comp.err) {\n            output = output.concat(\"\", \"\", \"-----obj-----\");\n            output = output.concat(comp.makeObj());\n        }\n        else {\n            output = output.concat(\"\", \"\", \"No obj generation due to errors in lst.\");\n        }\n        $(\"#output\").val(arrayToText(output));\n    }\n    catch (e) {\n        alert(e.message);\n    }\n});"]}