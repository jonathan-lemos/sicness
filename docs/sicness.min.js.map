{"version":3,"sources":["node_modules/browser-pack/_prelude.js","dist/SicCompiler/SicBase.js","dist/SicCompiler/SicBytecode.js","dist/SicCompiler/SicCompiler.js","dist/SicCompiler/SicCsect.js","dist/SicCompiler/SicFmt.js","dist/SicCompiler/SicFormat1.js","dist/SicCompiler/SicFormat2.js","dist/SicCompiler/SicFormat3.js","dist/SicCompiler/SicFormat4.js","dist/SicCompiler/SicFormatLegacy.js","dist/SicCompiler/SicLitTab.js","dist/SicCompiler/SicLiteral.js","dist/SicCompiler/SicLstEntry.js","dist/SicCompiler/SicOperandAddr.js","dist/SicCompiler/SicPending.js","dist/SicCompiler/SicRegConvert.js","dist/SicCompiler/SicSpace.js","dist/SicCompiler/SicSplit.js","dist/SicCompiler/SicUnsigned.js","dist/SicCompiler/SicUseTab.js","dist/app.js"],"names":["f","exports","module","define","amd","window","global","self","this","sicness","r","e","n","t","o","i","c","require","u","a","Error","code","p","call","length","1","Object","defineProperty","value","SicPending_1","SicBase","val","SicPending","prototype","ready","makeReady","tagTab","pending","convert","SicBytecode","mnemonic","opcode","format","mnemonicPvt","opcodePvt","formatPvt","get","enumerable","configurable","bytecodeTable","addBytecode","bc","writable","SicCsect_1","SicFormat1_1","SicFormat2_1","SicFormat3_1","SicFormat4_1","SicFormatLegacy_1","SicLstEntry_1","SicSpace_1","SicSplit_1","SicCompiler","lines","_this","ctab","SicCsectTab","errflag","forEach","replace","trim","split","SicSplit","instr","args","current","useTab","aloc","toString","_i","_a","keys","equTab","key","match","s","undefined","tag","isDirective","op","directives","SicFormat1","isFormat1","SicFormat2","isFormat2","SicFormat3","isFormat3","SicFormat4","isFormat4","SicFormatLegacy","isFormatLegacy","SicSpace","isSpace","addLst","SicLstEntry","loc","inst","inc","message","litTab","hasPending","correct","lst","l","bcData","res","extRefTab","modRecs","push","len","symbol","str","errmsg","makeLst","makeObj","SicBase_1","SicFmt_1","SicLiteral_1","SicLitTab_1","SicUseTab_1","SicCsect","startAddr","SicLitTab","SicUseTab","extDefTab","Set","setStartAddr","currentSect","csects","parseNum","reDec","RegExp","reHex","reChar","parseInt","x","ptr","slice","charCodeAt","RESW","source","RESB","START","startData","name","END","cs","csect","BASE","base","NOBASE","SILENT_LTORG","createOrg","v","asHex","SicLiteral","LTORG","EQU","USE","use","CSECT","EXTDEF","add","EXTREF","has","litPool","concat","map","ls","astr","rstr","inststr","hasInstruction","byteString","istr","msg","padEnd","mkH","asWord","mkD","defs","size","mkR","refs","mkT","arr","buf","asByte","bytesToString","toBytes","mkE","mkM","modrec","m","getLen","start","end","a_1","b","sloc","sname","forEachAux","filter","newSect","callback","curBuf","toUpperCase","padStart","reduce","acc","SicBytecode_1","line","SicRegConvert_1","SicUnsigned_1","matcher","reRegister","sicRegToDec","op1","sicCheckUnsigned","op2","bytes","SicOperandAddr_1","SicOperandAddr","SicOpType","f3","nixbpe","f4","charAt","legacy","ltorgs","getLitLoc","pc","diffMin","Number","MAX_SAFE_INTEGER","lt","Math","min","splitWord","byteCode","SicOpAddrType","arg","type","reDecimal","reTag","isLiteral","pcrel","addr","direct","indexed","rdy","char","immediate","indirect","getType","q","opLen","sicMakeUnsigned","isTag","reg","sicDecToReg","func","splitByte","test","lineArr","sicMakeMask","nBits","SicLocPair","rloc","startloc","ALOC","label","locsent","currentUse","finalPair","index","find","prev","SicCompiler_1","editor","ace","edit","setTheme","session","setMode","$","click","getValue","comp","output","err","alert"],"mappings":"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AAA,IAAAX,EAAA,MAAA,GAAA,IACAW,EAAA,IAAAX,EAAA,OAAA,GAAA,IACAW,EAAA,IAAAX,EAAA,MAAA,EAAA,IACAW,EAAA,IAAAX,EAAA,MAAA,IAAA,IACAW,EAAA,IAAAX,EAAA,OAAA,GAAA,IACAW,EAAA,IAAAX,EAAA,MAAA,IAAA,IACAW,EAAA,IAAAX,EAAA,MAAA,EAAA,IACAW,EAAA,IAAAX,EAAA,MAAA,IAAA,IACAW,EAAA,IAAAX,EAAA,MAAA,IAAA,IACAW,EAAA,IAAAX,EAAA,MAAA,EAAA,IACAW,EAAA,IAAAX,EAAA,MAAA,IAAA,IACAW,EAAA,IAAAX,EAAA,MAAA,GAAA,IACAW,EAAA,IAAAX,EAAA,OAAA,GAAA,IACAW,EAAA,IAAAX,EAAA,OAAA,IAAA,IACAW,EAAA,IAAAX,EAAA,OAAA,IAAA,IACAW,EAAA,IAAAX,EAAA,KAAA,GAAA,IACAW,EAAA,IAAAX,EAAA,KAAA,IAAA,IACAW,EAAA,IAAAX,EAAA,MAAA,IAAA,IACAW,EAAA,IAAAX,EAAA,OAAA,GAAA,IACAW,EAAA,IAAAX,EAAA,SAAA,IAAA,IACAW,EAAA,IAAAX,EAAA,SAAA,IAAA,IACAW,EAAA,IAAAX,EAAA,MAAA,IAAA,IACAW,EAAA,IAAAX,EAAA,MAAA,IAAA,IACAW,EAAA,IAAAX,EAAA,MAAA,GAAA,IACAW,EAAA,IAAAX,EAAA,MAAA,IAAA,IACAW,EAAA,IAAAX,EAAA,OAAA,GAAA,IACAW,EAAA,IAAAX,EAAA,MAAA,IAAA,IACAW,EAAA,IAAAX,EAAA,MAAA,IAAA,IACAW,EAAA,IAAAX,EAAA,MAAA,GAAA,IACAW,EAAA,IAAAX,EAAA,MAAA,IAAA,IACAW,EAAA,IAAAX,EAAA,OAAA,IAAA,IACAW,EAAA,IAAAX,EAAA,MAAA,IAAA,IACAW,EAAA,IAAAX,EAAA,MAAA,GAAA,IACAW,EAAA,IAAAX,EAAA,MAAA,GAAA,IACAW,EAAA,IAAAX,EAAA,OAAA,GAAA,IACAW,EAAA,IAAAX,EAAA,OAAA,IAAA,IACAW,EAAA,IAAAX,EAAA,MAAA,IAAA,IACAW,EAAA,IAAAX,EAAA,K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","file":"sicness.min.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SicPending_1 = require(\"./SicPending\");\nvar SicBase = (function () {\n    function SicBase(val) {\n        this.val = val;\n        if (this.val instanceof SicPending_1.SicPending && typeof this.val.val === \"number\") {\n            this.val = this.val.val;\n        }\n    }\n    SicBase.prototype.ready = function () {\n        return typeof this.val === \"number\";\n    };\n    SicBase.prototype.makeReady = function (p) {\n        if (typeof this.val === \"number\") {\n            return;\n        }\n        if (typeof p === \"number\") {\n            this.val = p;\n            return;\n        }\n        var tagTab = p;\n        var pending = this.val;\n        this.val = pending.convert(tagTab, null, null);\n    };\n    return SicBase;\n}());\nexports.SicBase = SicBase;","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SicBytecode = (function () {\n    function SicBytecode(mnemonic, opcode, format) {\n        this.mnemonicPvt = mnemonic;\n        this.opcodePvt = opcode;\n        this.formatPvt = format;\n    }\n    Object.defineProperty(SicBytecode.prototype, \"mnemonic\", {\n        get: function () {\n            return this.mnemonicPvt;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SicBytecode.prototype, \"opcode\", {\n        get: function () {\n            return this.opcodePvt;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SicBytecode.prototype, \"format\", {\n        get: function () {\n            return this.formatPvt;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return SicBytecode;\n}());\nexports.SicBytecode = SicBytecode;\nexports.bytecodeTable = {};\nvar addBytecode = function (bc) {\n    Object.defineProperty(exports.bytecodeTable, bc.mnemonic, {\n        configurable: true,\n        enumerable: true,\n        value: bc,\n        writable: false,\n    });\n};\naddBytecode(new SicBytecode(\"ADD\", 0x18, 3));\naddBytecode(new SicBytecode(\"ADDF\", 0x58, 3));\naddBytecode(new SicBytecode(\"ADDR\", 0x90, 2));\naddBytecode(new SicBytecode(\"AND\", 0x40, 3));\naddBytecode(new SicBytecode(\"CLEAR\", 0xB4, 2));\naddBytecode(new SicBytecode(\"COMP\", 0x28, 3));\naddBytecode(new SicBytecode(\"COMPF\", 0x88, 3));\naddBytecode(new SicBytecode(\"COMPR\", 0xA0, 2));\naddBytecode(new SicBytecode(\"DIV\", 0x24, 3));\naddBytecode(new SicBytecode(\"DIVF\", 0x64, 3));\naddBytecode(new SicBytecode(\"DIVR\", 0x9C, 2));\naddBytecode(new SicBytecode(\"FIX\", 0xC4, 1));\naddBytecode(new SicBytecode(\"FLOAT\", 0xC0, 1));\naddBytecode(new SicBytecode(\"HIO\", 0xF4, 1));\naddBytecode(new SicBytecode(\"J\", 0x3C, 3));\naddBytecode(new SicBytecode(\"JEQ\", 0x30, 3));\naddBytecode(new SicBytecode(\"JGT\", 0x34, 3));\naddBytecode(new SicBytecode(\"JLT\", 0x38, 3));\naddBytecode(new SicBytecode(\"JSUB\", 0x48, 3));\naddBytecode(new SicBytecode(\"LDA\", 0x00, 3));\naddBytecode(new SicBytecode(\"LDB\", 0x68, 3));\naddBytecode(new SicBytecode(\"LDCH\", 0x50, 3));\naddBytecode(new SicBytecode(\"LDF\", 0x70, 3));\naddBytecode(new SicBytecode(\"LDL\", 0x08, 3));\naddBytecode(new SicBytecode(\"LDS\", 0x6C, 3));\naddBytecode(new SicBytecode(\"LDT\", 0x74, 3));\naddBytecode(new SicBytecode(\"LDX\", 0x04, 3));\naddBytecode(new SicBytecode(\"LPS\", 0xD0, 3));\naddBytecode(new SicBytecode(\"MUL\", 0x20, 3));\naddBytecode(new SicBytecode(\"MULF\", 0x60, 3));\naddBytecode(new SicBytecode(\"MULR\", 0x98, 2));\naddBytecode(new SicBytecode(\"NORM\", 0xC8, 1));\naddBytecode(new SicBytecode(\"OR\", 0x44, 3));\naddBytecode(new SicBytecode(\"RD\", 0xD8, 3));\naddBytecode(new SicBytecode(\"RMO\", 0xAC, 2));\naddBytecode(new SicBytecode(\"RSUB\", 0x4C, 3));\naddBytecode(new SicBytecode(\"SHIFTL\", 0xA4, 2));\naddBytecode(new SicBytecode(\"SHIFTR\", 0xA8, 2));\naddBytecode(new SicBytecode(\"SIO\", 0xF0, 1));\naddBytecode(new SicBytecode(\"SSK\", 0xEC, 3));\naddBytecode(new SicBytecode(\"STA\", 0x0C, 3));\naddBytecode(new SicBytecode(\"STB\", 0x78, 3));\naddBytecode(new SicBytecode(\"STCH\", 0x54, 3));\naddBytecode(new SicBytecode(\"STF\", 0x80, 3));\naddBytecode(new SicBytecode(\"STI\", 0xD4, 3));\naddBytecode(new SicBytecode(\"STL\", 0x14, 3));\naddBytecode(new SicBytecode(\"STS\", 0x7C, 3));\naddBytecode(new SicBytecode(\"STSW\", 0xE8, 3));\naddBytecode(new SicBytecode(\"STT\", 0x84, 3));\naddBytecode(new SicBytecode(\"STX\", 0x10, 3));\naddBytecode(new SicBytecode(\"SUB\", 0x1C, 3));\naddBytecode(new SicBytecode(\"SUBF\", 0x5C, 3));\naddBytecode(new SicBytecode(\"SUBR\", 0x94, 2));\naddBytecode(new SicBytecode(\"SVC\", 0xB0, 2));\naddBytecode(new SicBytecode(\"TD\", 0xE0, 3));\naddBytecode(new SicBytecode(\"TIO\", 0xF8, 1));\naddBytecode(new SicBytecode(\"TIX\", 0x2C, 3));\naddBytecode(new SicBytecode(\"TIXR\", 0xB8, 2));\naddBytecode(new SicBytecode(\"WD\", 0xDC, 3));","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SicCsect_1 = require(\"./SicCsect\");\nvar SicFormat1_1 = require(\"./SicFormat1\");\nvar SicFormat2_1 = require(\"./SicFormat2\");\nvar SicFormat3_1 = require(\"./SicFormat3\");\nvar SicFormat4_1 = require(\"./SicFormat4\");\nvar SicFormatLegacy_1 = require(\"./SicFormatLegacy\");\nvar SicLstEntry_1 = require(\"./SicLstEntry\");\nvar SicSpace_1 = require(\"./SicSpace\");\nvar SicSplit_1 = require(\"./SicSplit\");\nvar SicCompiler = (function () {\n    function SicCompiler(lines) {\n        var _this = this;\n        this.ctab = new SicCsect_1.SicCsectTab();\n        this.errflag = false;\n        lines.forEach(function (val) {\n            try {\n                if (val.replace(/\\..*$/, \"\").trim() === \"\") {\n                    return;\n                }\n                var split = new SicSplit_1.SicSplit(val);\n                var instr = void 0;\n                split.args.replace(/(#|@|=)\\*$/, \"$1\" + _this.ctab.current.useTab.aloc.toString(10));\n                for (var _i = 0, _a = Object.keys(_this.ctab.current.equTab); _i < _a.length; _i++) {\n                    var key = _a[_i];\n                    if (split.args.match(key) === null) {\n                        continue;\n                    }\n                    for (var s = _this.ctab.current.equTab[key]; s !== undefined; s = _this.ctab.current.equTab[s]) {\n                        split.args = split.args.replace(key, _this.ctab.current.equTab[key]);\n                    }\n                    break;\n                }\n                if (split.tag !== \"\") {\n                    if (_this.ctab.current.tagTab[split.tag] !== undefined) {\n                        throw new Error(\"Duplicate label \" + split.tag);\n                    }\n                    _this.ctab.current.tagTab[split.tag] = _this.ctab.current.useTab.aloc;\n                }\n                if (_this.ctab.isDirective(split.op)) {\n                    _this.ctab.directives[split.op](val, split);\n                    return;\n                }\n                if (SicFormat1_1.SicFormat1.isFormat1(split.op)) {\n                    instr = new SicFormat1_1.SicFormat1(split);\n                }\n                else if (SicFormat2_1.SicFormat2.isFormat2(split.op)) {\n                    instr = new SicFormat2_1.SicFormat2(split);\n                }\n                else if (SicFormat3_1.SicFormat3.isFormat3(split.op)) {\n                    instr = new SicFormat3_1.SicFormat3(split, _this.ctab.current);\n                }\n                else if (SicFormat4_1.SicFormat4.isFormat4(split.op)) {\n                    instr = new SicFormat4_1.SicFormat4(split, _this.ctab.current);\n                }\n                else if (SicFormatLegacy_1.SicFormatLegacy.isFormatLegacy(split.op)) {\n                    instr = new SicFormatLegacy_1.SicFormatLegacy(split, _this.ctab.current);\n                }\n                else if (SicSpace_1.SicSpace.isSpace(split.op)) {\n                    instr = new SicSpace_1.SicSpace(split);\n                }\n                else {\n                    throw new Error(split.op + \" is not a valid mnemonic.\");\n                }\n                _this.ctab.addLst(new SicLstEntry_1.SicLstEntry(val, { loc: _this.ctab.current.useTab.loc(), inst: instr }));\n                _this.ctab.current.useTab.inc(instr.length());\n            }\n            catch (e) {\n                _this.errflag = true;\n                _this.ctab.addLst(new SicLstEntry_1.SicLstEntry(val, e.message));\n            }\n        });\n        this.ctab.forEach(function (p) {\n            if (p.litTab.hasPending()) {\n                _this.ctab.directives[\"SILENT_LTORG\"](\"\", new SicSplit_1.SicSplit(\"\\tSILENT_LTORG\"));\n            }\n            p.useTab.correct();\n        });\n        this.ctab.forEach(function (p) {\n            p.lst.forEach(function (l) {\n                if (l.bcData !== undefined && l.bcData.inst !== undefined && !l.bcData.inst.ready()) {\n                    try {\n                        var res = l.bcData.inst.makeReady(l.bcData.loc.a, p.tagTab, p.litTab, p.extRefTab);\n                        if (res !== null) {\n                            p.modRecs.push({ loc: l.bcData.loc.a, len: 5, symbol: res });\n                        }\n                    }\n                    catch (e) {\n                        var str = e.message;\n                        l.bcData = undefined;\n                        l.errmsg = str;\n                    }\n                }\n            });\n        });\n    }\n    SicCompiler.prototype.makeLst = function () {\n        return this.ctab.makeLst();\n    };\n    SicCompiler.prototype.makeObj = function () {\n        return this.ctab.makeObj();\n    };\n    Object.defineProperty(SicCompiler.prototype, \"err\", {\n        get: function () {\n            return this.errflag;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return SicCompiler;\n}());\nexports.SicCompiler = SicCompiler;","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SicBase_1 = require(\"./SicBase\");\nvar SicFmt_1 = require(\"./SicFmt\");\nvar SicLiteral_1 = require(\"./SicLiteral\");\nvar SicLitTab_1 = require(\"./SicLitTab\");\nvar SicLstEntry_1 = require(\"./SicLstEntry\");\nvar SicPending_1 = require(\"./SicPending\");\nvar SicSplit_1 = require(\"./SicSplit\");\nvar SicUseTab_1 = require(\"./SicUseTab\");\nvar SicCsect = (function () {\n    function SicCsect(startAddr) {\n        this.lst = [];\n        this.litTab = new SicLitTab_1.SicLitTab();\n        this.tagTab = {};\n        this.equTab = {};\n        this.useTab = new SicUseTab_1.SicUseTab(startAddr);\n        this.extDefTab = new Set();\n        this.extRefTab = new Set();\n        this.modRecs = [];\n    }\n    SicCsect.prototype.setStartAddr = function (startAddr) {\n        this.useTab = new SicUseTab_1.SicUseTab(startAddr);\n    };\n    return SicCsect;\n}());\nexports.SicCsect = SicCsect;\nvar SicCsectTab = (function () {\n    function SicCsectTab() {\n        var _this = this;\n        this.currentSect = \"\";\n        this.csects = {};\n        this.csects[this.currentSect] = new SicCsect(0);\n        this.lst = [];\n        var parseNum = function (val) {\n            var reDec = new RegExp(\"^(\\\\d+)$\");\n            var reHex = new RegExp(\"^X'([0-9A-Fa-f]+)'$\");\n            var reChar = new RegExp(\"^C'.{1,3}'$\");\n            var match;\n            if ((match = val.match(reDec)) !== null) {\n                return parseInt(match[1], 10);\n            }\n            if ((match = val.match(reHex)) !== null) {\n                return parseInt(match[1], 16);\n            }\n            if ((match = val.match(reChar)) !== null) {\n                var x = 0;\n                for (var ptr = 0, s = match[1]; s !== \"\"; ptr += 8, s = s.slice(0, -1)) {\n                    x += s.charCodeAt(s.length - 1) << ptr;\n                }\n                return x;\n            }\n            throw new Error(val + \" was not of a valid numeric format.\");\n        };\n        this.directives = {\n            RESW: function (source, split) {\n                _this.addLst(new SicLstEntry_1.SicLstEntry(source, { loc: _this.current.useTab.loc(), inst: undefined }));\n                _this.current.useTab.inc(3 * parseNum(split.args));\n            },\n            RESB: function (source, split) {\n                _this.addLst(new SicLstEntry_1.SicLstEntry(source, { loc: _this.current.useTab.loc(), inst: undefined }));\n                _this.current.useTab.inc(parseNum(split.args));\n            },\n            START: function (source, split) {\n                if (_this.currentSect !== \"\" || _this.current.lst.length !== 0) {\n                    throw new Error(\"START can only be used as the first line of a program.\");\n                }\n                _this.current.setStartAddr(parseInt(split.args, 16));\n                _this.addLst(new SicLstEntry_1.SicLstEntry(source, { loc: _this.current.useTab.loc(), inst: undefined }));\n                _this.startData = { name: split.tag, loc: _this.current.useTab.aloc };\n            },\n            END: function (source, split) {\n                var cs;\n                if (split.args === \"\") {\n                    throw new Error(\"END must have a label\");\n                }\n                if (_this.startData !== undefined && _this.startData.name === split.args) {\n                    cs = \"\";\n                }\n                else if (_this.csects[name] === undefined) {\n                    throw new Error(split.args + \" does not correspond to any given CSECT/START label.\");\n                }\n                else {\n                    cs = split.args;\n                }\n                _this.csect(cs);\n                if (_this.current.litTab.hasPending()) {\n                    _this.directives[\"SILENT_LTORG\"](\"\", new SicSplit_1.SicSplit(\"\\tSILENT_LTORG\"));\n                }\n                _this.current.useTab.correct();\n                if ((_this.startData === undefined && split.args !== \"\") ||\n                    (_this.startData !== undefined && split.args !== _this.startData.name)) {\n                    throw new Error(\"END label must be the same as the start label.\");\n                }\n                _this.addLst(new SicLstEntry_1.SicLstEntry(source, { loc: _this.current.useTab.loc(), inst: undefined }));\n            },\n            BASE: function (source, split) {\n                try {\n                    _this.current.base = new SicBase_1.SicBase(parseNum(split.args));\n                }\n                catch (e) {\n                    _this.current.base = new SicBase_1.SicBase(new SicPending_1.SicPending(split.args));\n                }\n                _this.addLst(new SicLstEntry_1.SicLstEntry(source));\n            },\n            NOBASE: function (source, split) {\n                _this.current.base = undefined;\n                _this.addLst(new SicLstEntry_1.SicLstEntry(source));\n            },\n            SILENT_LTORG: function (source, split) {\n                var l = _this.current.litTab.createOrg(_this.current.useTab.aloc);\n                l.forEach(function (v) {\n                    _this.addLst(new SicLstEntry_1.SicLstEntry(\"X'\" + SicFmt_1.asHex(v.val) + \"' BYTE X'\" + SicFmt_1.asHex(v.val) + \"'\", { loc: _this.current.useTab.loc(), inst: new SicLiteral_1.SicLiteral(v.val) }));\n                    _this.current.useTab.inc(3);\n                });\n            },\n            LTORG: function (source, split) {\n                _this.addLst(new SicLstEntry_1.SicLstEntry(source));\n                var l = _this.current.litTab.createOrg(_this.current.useTab.aloc);\n                l.forEach(function (v) {\n                    _this.addLst(new SicLstEntry_1.SicLstEntry(\"X'\" + SicFmt_1.asHex(v.val) + \"' BYTE X'\" + SicFmt_1.asHex(v.val) + \"'\", { loc: _this.current.useTab.loc(), inst: new SicLiteral_1.SicLiteral(v.val) }));\n                    _this.current.useTab.inc(3);\n                });\n            },\n            EQU: function (source, split) {\n                if (split.tag === \"\") {\n                    throw new Error(\"EQU needs a non-empty label.\");\n                }\n                if (_this.current.equTab[split.args] !== undefined) {\n                    throw new Error(\"EQU \" + split.args + \" was already defined.\");\n                }\n                _this.current.equTab[split.tag] = split.args;\n                _this.addLst(new SicLstEntry_1.SicLstEntry(source));\n            },\n            USE: function (source, split) {\n                _this.current.useTab.use(split.args);\n                _this.addLst(new SicLstEntry_1.SicLstEntry(source, { loc: _this.current.useTab.loc(), inst: undefined }));\n            },\n            CSECT: function (source, split) {\n                _this.addLst(new SicLstEntry_1.SicLstEntry(source));\n                _this.csect(split.tag);\n            },\n            EXTDEF: function (source, split) {\n                var s = split.args.split(\",\");\n                _this.addLst(new SicLstEntry_1.SicLstEntry(source));\n                s.forEach(function (r) { return _this.current.extDefTab.add(r); });\n            },\n            EXTREF: function (source, split) {\n                var s = split.args.split(\",\");\n                _this.addLst(new SicLstEntry_1.SicLstEntry(source));\n                s.forEach(function (r) {\n                    if (_this.current.extRefTab.has(r)) {\n                        throw new Error(\"Duplicate EXTREF \" + r);\n                    }\n                    if (_this.current.tagTab[r] !== undefined) {\n                        throw new Error(\"Duplicate label \" + r);\n                    }\n                    _this.current.extRefTab.add(r);\n                });\n            },\n        };\n    }\n    SicCsectTab.prototype.litPool = function () {\n        var _this = this;\n        var l = this.current.litTab.createOrg(this.current.useTab.aloc);\n        l.forEach(function (v) {\n            _this.addLst(new SicLstEntry_1.SicLstEntry(\"X'\" + SicFmt_1.asHex(v.val) + \"' BYTE X'\" + SicFmt_1.asHex(v.val) + \"'\", { loc: _this.current.useTab.loc(), inst: new SicLiteral_1.SicLiteral(v.val) }));\n            _this.current.useTab.inc(3);\n        });\n    };\n    SicCsectTab.prototype.isDirective = function (mnemonic) {\n        if (mnemonic === \"SILENT_LTORG\") {\n            return false;\n        }\n        return this.directives[mnemonic] !== undefined;\n    };\n    SicCsectTab.prototype.addLst = function (l) {\n        this.lst.push(l);\n        this.current.lst.push(l);\n    };\n    SicCsectTab.prototype.makeLst = function () {\n        var s = [\"n\"];\n        s[0] = \"n    \\taloc \\trloc \\tbytecode\\tsource\";\n        s[1] = \"-----\\t-----\\t-----\\t--------\\t------\";\n        var i = 1;\n        return s.concat(this.lst.map(function (ls) {\n            var astr = ls.bcData === undefined ? \"\" : SicFmt_1.asHex(ls.bcData.loc.a);\n            var rstr = ls.bcData === undefined ? \"\" : SicFmt_1.asHex(ls.bcData.loc.r);\n            var inststr = ls.hasInstruction() ? ls.byteString() : \"\";\n            var istr = i.toString(10);\n            ++i;\n            var msg = istr.padEnd(5, \" \") + \"\\t\" +\n                astr.padEnd(5, \" \") + \"\\t\" +\n                rstr.padEnd(5, \" \") + \"\\t\" +\n                inststr.padEnd(8, \" \") + \"\\t\" +\n                ls.source;\n            if (ls.errmsg !== undefined) {\n                msg += \"\\n* Error: \" + ls.errmsg + \" *\";\n            }\n            return msg;\n        }));\n    };\n    SicCsectTab.prototype.makeObj = function () {\n        var s = [];\n        var mkH = function (len, loc, name) {\n            if (loc === undefined) {\n                loc = 0;\n            }\n            if (name === undefined) {\n                name = \"\";\n            }\n            return \"H \" + name + \" \" + SicFmt_1.asWord(loc) + \" \" + SicFmt_1.asWord(len);\n        };\n        var mkD = function (defs, tagTab) {\n            if (defs.size === 0) {\n                return \"\";\n            }\n            var a = \"D \";\n            defs.forEach(function (v) { return a += v + \" \" + SicFmt_1.asWord(tagTab[v]); }, \"\");\n            return a;\n        };\n        var mkR = function (refs) {\n            if (refs.size === 0) {\n                return \"\";\n            }\n            var a = \"R \";\n            refs.forEach(function (v) { return a += v + \" \"; }, \"\");\n            return a.trim();\n        };\n        var mkT = function (arr) {\n            var buf = [];\n            arr.forEach(function (l) {\n                if (l.bcData === undefined || l.bcData.inst === undefined) {\n                    return;\n                }\n                buf.push(\"T \" + SicFmt_1.asWord(l.bcData.loc.a) + \" \" + SicFmt_1.asByte(l.bcData.inst.length()) + \" \" + SicFmt_1.bytesToString(l.bcData.inst.toBytes()));\n            });\n            return buf;\n        };\n        var mkE = function (loc) {\n            if (loc === undefined) {\n                return \"E\";\n            }\n            return \"E \" + SicFmt_1.asWord(loc);\n        };\n        var mkM = function (modrec) {\n            return modrec.map(function (m) {\n                return \"M \" + SicFmt_1.asWord(m.loc) + \" \" + SicFmt_1.asByte(m.len) + \" +\" + m.symbol;\n            });\n        };\n        var getLen = function (a) {\n            var start = 0;\n            var end = 0;\n            for (var _i = 0, a_1 = a; _i < a_1.length; _i++) {\n                var b = a_1[_i];\n                if (b.bcData !== undefined) {\n                    start = b.bcData.loc.a;\n                    break;\n                }\n            }\n            for (var i = a.length - 1; i >= 0; --i) {\n                var bc = a[i].bcData;\n                if (bc !== undefined) {\n                    end = bc.loc.a + (bc.inst !== undefined ? bc.inst.length() : 0);\n                    break;\n                }\n            }\n            return end - start;\n        };\n        var sloc = this.startData !== undefined ? this.startData.loc : 0;\n        var sname = this.startData !== undefined ? this.startData.name : \"\";\n        s.push(mkH(getLen(this.csects[\"\"].lst), sloc, sname));\n        s.push(mkD(this.csects[\"\"].extDefTab, this.csects[\"\"].tagTab));\n        s.push(mkR(this.csects[\"\"].extRefTab));\n        s = s.concat(mkT(this.csects[\"\"].lst));\n        s = s.concat(mkM(this.csects[\"\"].modRecs));\n        s.push(mkE(sloc));\n        this.forEachAux(function (c, n) {\n            s.push(mkH(getLen(c.lst), 0, n));\n            s.push(mkD(c.extDefTab, c.tagTab));\n            s.push(mkR(c.extRefTab));\n            s = s.concat(mkT(c.lst));\n            s = s.concat(mkM(c.modRecs));\n            s.push(mkE());\n        });\n        return s.filter(function (r) { return r !== \"\"; });\n    };\n    Object.defineProperty(SicCsectTab.prototype, \"current\", {\n        get: function () {\n            return this.csects[this.currentSect];\n        },\n        enumerable: true,\n        configurable: true\n    });\n    SicCsectTab.prototype.csect = function (newSect) {\n        this.currentSect = newSect;\n        if (this.csects[this.currentSect] === undefined) {\n            this.csects[this.currentSect] = new SicCsect(0);\n        }\n    };\n    Object.defineProperty(SicCsectTab.prototype, \"default\", {\n        get: function () {\n            return this.csects[\"\"];\n        },\n        enumerable: true,\n        configurable: true\n    });\n    SicCsectTab.prototype.forEach = function (callback) {\n        var _this = this;\n        var curBuf = this.currentSect;\n        Object.keys(this.csects).forEach(function (c) {\n            _this.currentSect = c;\n            callback(_this.csects[c], c);\n        });\n        this.currentSect = curBuf;\n    };\n    SicCsectTab.prototype.forEachAux = function (callback) {\n        var _this = this;\n        var curBuf = this.currentSect;\n        Object.keys(this.csects).forEach(function (c) {\n            if (c === \"\") {\n                return;\n            }\n            _this.currentSect = c;\n            callback(_this.csects[c], c);\n        });\n        this.currentSect = curBuf;\n    };\n    return SicCsectTab;\n}());\nexports.SicCsectTab = SicCsectTab;","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.asHex = function (n) { return n.toString(16).toUpperCase(); };\nexports.asWord = function (n) { return exports.asHex(n).padStart(6, \"0\"); };\nexports.asByte = function (n) { return exports.asHex(n).padStart(2, \"0\"); };\nexports.bytesToString = function (n) { return n.reduce(function (acc, val) { return acc + exports.asByte(val); }, \"\"); };","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SicBytecode_1 = require(\"./SicBytecode\");\nvar SicFormat1 = (function () {\n    function SicFormat1(line) {\n        if (!SicFormat1.isFormat1(line.op)) {\n            throw new Error(line.op + \" is not a format 1 operation\");\n        }\n        if (line.args !== \"\") {\n            throw new Error(\"Format 1 arguments cannot have arguments\");\n        }\n        this.bc = SicBytecode_1.bytecodeTable[line.op];\n    }\n    SicFormat1.isFormat1 = function (mnemonic) {\n        var bc = SicBytecode_1.bytecodeTable[mnemonic];\n        return bc !== undefined && bc.format === 1;\n    };\n    SicFormat1.prototype.ready = function () {\n        return true;\n    };\n    SicFormat1.prototype.makeReady = function (loc, tagTab, litTab, extRefTab) {\n        return null;\n    };\n    SicFormat1.prototype.length = function () {\n        return 1;\n    };\n    SicFormat1.prototype.toBytes = function () {\n        return [this.bc.opcode];\n    };\n    return SicFormat1;\n}());\nexports.SicFormat1 = SicFormat1;","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SicBytecode_1 = require(\"./SicBytecode\");\nvar SicRegConvert_1 = require(\"./SicRegConvert\");\nvar SicUnsigned_1 = require(\"./SicUnsigned\");\nvar SicFormat2 = (function () {\n    function SicFormat2(line) {\n        if (!SicFormat2.isFormat2(line.op)) {\n            throw new Error(line.op + \" is not a format 2 opcode\");\n        }\n        this.bc = SicBytecode_1.bytecodeTable[line.op];\n        var s = line.args.trim().split(/\\s*,\\s*/);\n        if (s.length === 1) {\n            s.push(\"0\");\n        }\n        if (s.length !== 2) {\n            throw new Error(\"This format 2 instruction has an invalid number of operands.\");\n        }\n        var matcher = function (str) {\n            var reRegister = new RegExp(\"^(A|X|L|PC|SW|B|S|T|F)$\");\n            var reHex = new RegExp(\"^X'([0-9A-Fa-f]+)'$\");\n            var reDec = new RegExp(\"^([0-9]+)$\");\n            var match;\n            if ((match = str.match(reRegister)) !== null) {\n                return SicRegConvert_1.sicRegToDec(match[1]);\n            }\n            else if ((match = str.match(reHex)) !== null) {\n                return parseInt(match[1], 16);\n            }\n            else if ((match = str.match(reDec)) !== null) {\n                return parseInt(match[1], 10);\n            }\n            throw new Error(str + \" is not a valid format 2 operand.\");\n        };\n        this.op1 = matcher(s[0]);\n        SicUnsigned_1.sicCheckUnsigned(this.op1, 4);\n        this.op2 = matcher(s[1]);\n        SicUnsigned_1.sicCheckUnsigned(this.op2, 4);\n    }\n    SicFormat2.isFormat2 = function (mnemonic) {\n        var bc = SicBytecode_1.bytecodeTable[mnemonic];\n        return bc !== undefined && bc.format === 2;\n    };\n    SicFormat2.prototype.ready = function () {\n        return true;\n    };\n    SicFormat2.prototype.makeReady = function (loc, tagTab, litTab, extRefTab) {\n        return null;\n    };\n    SicFormat2.prototype.length = function () {\n        return 2;\n    };\n    SicFormat2.prototype.toBytes = function () {\n        var bytes = [0x00, 0x00];\n        bytes[0] = this.bc.opcode;\n        bytes[1] |= (this.op1 & 0x0F) << 4;\n        bytes[1] |= (this.op2 & 0x0F);\n        return bytes;\n    };\n    return SicFormat2;\n}());\nexports.SicFormat2 = SicFormat2;","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SicBytecode_1 = require(\"./SicBytecode\");\nvar SicOperandAddr_1 = require(\"./SicOperandAddr\");\nvar SicFormat3 = (function () {\n    function SicFormat3(line, csect) {\n        if (!SicFormat3.isFormat3(line.op)) {\n            throw new Error(line.op + \" is not format 3\");\n        }\n        this.bc = SicBytecode_1.bytecodeTable[line.op];\n        this.op = new SicOperandAddr_1.SicOperandAddr(line.args, SicOperandAddr_1.SicOpType.f3, csect);\n    }\n    SicFormat3.isFormat3 = function (mnemonic) {\n        var bc = SicBytecode_1.bytecodeTable[mnemonic];\n        return bc !== undefined && bc.format === 3;\n    };\n    SicFormat3.prototype.makeReady = function (loc, tagTab, litTab, extRefTab) {\n        return this.op.makeReady(loc + this.length(), tagTab, litTab, extRefTab);\n    };\n    SicFormat3.prototype.ready = function () {\n        return this.op.ready();\n    };\n    SicFormat3.prototype.length = function () {\n        return 3;\n    };\n    SicFormat3.prototype.toBytes = function () {\n        if (!this.ready()) {\n            throw new Error(\"Internal error: This SicFormat3 instruction is not ready.\");\n        }\n        var bytes = this.op.nixbpe();\n        bytes[0] |= (this.bc.opcode & 0xFC);\n        bytes[1] |= (this.op.val & 0x0F00) >>> 8;\n        bytes[2] = (this.op.val & 0xFF);\n        return bytes;\n    };\n    return SicFormat3;\n}());\nexports.SicFormat3 = SicFormat3;","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SicBytecode_1 = require(\"./SicBytecode\");\nvar SicOperandAddr_1 = require(\"./SicOperandAddr\");\nvar SicFormat4 = (function () {\n    function SicFormat4(line, csect) {\n        if (!SicFormat4.isFormat4(line.op)) {\n            throw new Error(line.op + \" is not format 4\");\n        }\n        this.bc = SicBytecode_1.bytecodeTable[line.op.slice(1)];\n        this.op = new SicOperandAddr_1.SicOperandAddr(line.args, SicOperandAddr_1.SicOpType.f4, csect);\n    }\n    SicFormat4.isFormat4 = function (mnemonic) {\n        if (mnemonic.charAt(0) !== \"+\") {\n            return false;\n        }\n        var bc = SicBytecode_1.bytecodeTable[mnemonic.slice(1)];\n        return bc !== undefined && bc.format === 3;\n    };\n    SicFormat4.prototype.makeReady = function (loc, tagTab, litTab, extRefTab) {\n        return this.op.makeReady(loc + this.length(), tagTab, litTab, extRefTab);\n    };\n    SicFormat4.prototype.ready = function () {\n        return this.op.ready();\n    };\n    SicFormat4.prototype.length = function () {\n        return 4;\n    };\n    SicFormat4.prototype.toBytes = function () {\n        if (!this.ready()) {\n            throw new Error(\"Internal error: This SicFormat4 instruction is not ready.\");\n        }\n        var bytes = this.op.nixbpe();\n        bytes[0] |= (this.bc.opcode & 0xFC);\n        bytes[1] |= (this.op.val & 0x0F0000) >>> 16;\n        bytes[2] = (this.op.val & 0xFF00) >>> 8;\n        bytes[3] = (this.op.val & 0xFF);\n        return bytes;\n    };\n    return SicFormat4;\n}());\nexports.SicFormat4 = SicFormat4;","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SicBytecode_1 = require(\"./SicBytecode\");\nvar SicOperandAddr_1 = require(\"./SicOperandAddr\");\nvar SicFormatLegacy = (function () {\n    function SicFormatLegacy(line, csect) {\n        if (!SicFormatLegacy.isFormatLegacy(line.op)) {\n            throw new Error(line.op + \" is not SIC legacy format\");\n        }\n        this.bc = SicBytecode_1.bytecodeTable[line.op.slice(1)];\n        this.op = new SicOperandAddr_1.SicOperandAddr(line.args, SicOperandAddr_1.SicOpType.legacy, csect);\n    }\n    SicFormatLegacy.isFormatLegacy = function (mnemonic) {\n        if (mnemonic.charAt(0) !== \"*\") {\n            return false;\n        }\n        var bc = SicBytecode_1.bytecodeTable[mnemonic.slice(1)];\n        return bc !== undefined && bc.format === 3;\n    };\n    SicFormatLegacy.prototype.makeReady = function (loc, tagTab, litTab, extRefTab) {\n        return this.op.makeReady(loc + this.length(), tagTab, litTab, extRefTab);\n    };\n    SicFormatLegacy.prototype.ready = function () {\n        return this.op.ready();\n    };\n    SicFormatLegacy.prototype.length = function () {\n        return 3;\n    };\n    SicFormatLegacy.prototype.toBytes = function () {\n        if (!this.ready()) {\n            throw new Error(\"Internal error: This SicFormatLegacy instruction is not ready.\");\n        }\n        var bytes = this.op.nixbpe();\n        bytes[0] |= (this.bc.opcode & 0xFC);\n        bytes[1] |= (this.op.val & 0x7F00) >>> 8;\n        bytes[2] = (this.op.val & 0xFF);\n        return bytes;\n    };\n    return SicFormatLegacy;\n}());\nexports.SicFormatLegacy = SicFormatLegacy;","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SicLitTab = (function () {\n    function SicLitTab() {\n        this.ltorgs = [];\n        this.pending = new Set();\n    }\n    SicLitTab.prototype.getLitLoc = function (n, pc) {\n        if (pc === void 0) { pc = 0; }\n        var diffMin = Number.MAX_SAFE_INTEGER;\n        var loc = null;\n        this.ltorgs.forEach(function (lt) {\n            if (lt.val === n && diffMin > Math.min(lt.loc - pc, lt.loc)) {\n                diffMin = Math.min(lt.loc - pc, lt.loc);\n                loc = lt.loc;\n            }\n        });\n        return loc;\n    };\n    SicLitTab.prototype.createOrg = function (loc) {\n        var l = loc;\n        var m = [];\n        var lt = this.pending.forEach(function (v) {\n            m.push({ loc: l, val: v });\n            l += 3;\n        });\n        this.ltorgs = this.ltorgs.concat(m);\n        this.pending = new Set();\n        return m;\n    };\n    SicLitTab.prototype.add = function (n) {\n        if (this.getLitLoc(n) === null) {\n            this.pending.add(n);\n        }\n    };\n    SicLitTab.prototype.hasPending = function (n) {\n        if (n === undefined) {\n            return this.pending.size > 0;\n        }\n        return this.pending.has(n);\n    };\n    return SicLitTab;\n}());\nexports.SicLitTab = SicLitTab;","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SicSpace_1 = require(\"./SicSpace\");\nvar SicLiteral = (function () {\n    function SicLiteral(val) {\n        this.val = val;\n    }\n    SicLiteral.prototype.length = function () {\n        return 3;\n    };\n    SicLiteral.prototype.ready = function () {\n        return true;\n    };\n    SicLiteral.prototype.makeReady = function (loc, tagTab, litTab, extRefTab) {\n        return null;\n    };\n    SicLiteral.prototype.toBytes = function () {\n        return SicSpace_1.SicSpace.splitWord(this.val);\n    };\n    return SicLiteral;\n}());\nexports.SicLiteral = SicLiteral;","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SicFmt_1 = require(\"./SicFmt\");\nvar SicLstEntry = (function () {\n    function SicLstEntry(source, bcData) {\n        this.source = source;\n        if (typeof bcData === \"string\") {\n            this.bcData = undefined;\n            this.errmsg = bcData;\n        }\n        else {\n            this.bcData = bcData;\n            this.errmsg = undefined;\n        }\n    }\n    SicLstEntry.prototype.hasInstruction = function () {\n        return this.bcData !== undefined && this.bcData.inst !== undefined;\n    };\n    SicLstEntry.prototype.byteCode = function () {\n        if (!(this.bcData !== undefined && this.bcData.inst !== undefined)) {\n            throw new Error(\"This SicLstEntry does not have an instruction in it\");\n        }\n        return this.bcData.inst.toBytes();\n    };\n    SicLstEntry.prototype.byteString = function () {\n        return SicFmt_1.bytesToString(this.byteCode());\n    };\n    return SicLstEntry;\n}());\nexports.SicLstEntry = SicLstEntry;","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SicPending_1 = require(\"./SicPending\");\nvar SicUnsigned_1 = require(\"./SicUnsigned\");\nvar SicOpAddrType;\n(function (SicOpAddrType) {\n    SicOpAddrType[SicOpAddrType[\"immediate\"] = 0] = \"immediate\";\n    SicOpAddrType[SicOpAddrType[\"direct\"] = 1] = \"direct\";\n    SicOpAddrType[SicOpAddrType[\"indirect\"] = 2] = \"indirect\";\n})(SicOpAddrType = exports.SicOpAddrType || (exports.SicOpAddrType = {}));\nvar SicOpType;\n(function (SicOpType) {\n    SicOpType[SicOpType[\"f3\"] = 0] = \"f3\";\n    SicOpType[SicOpType[\"f4\"] = 1] = \"f4\";\n    SicOpType[SicOpType[\"legacy\"] = 2] = \"legacy\";\n})(SicOpType = exports.SicOpType || (exports.SicOpType = {}));\nvar SicOperandAddr = (function () {\n    function SicOperandAddr(arg, type, csect) {\n        var reDecimal = new RegExp(\"^(=|#|@)?(-?\\\\d+)(,X)?$\");\n        var reHex = new RegExp(\"^(=|#|@)?X'([0-9A-F]+)'(,X)?$\");\n        var reChar = new RegExp(\"^(=|#|@)?C'(.{1,3})'(,X)?$\");\n        var reTag = new RegExp(\"^(#|@)?([A-Z0-9]+)(,X)?$\");\n        var getType = function (char) {\n            switch (char) {\n                case \"#\":\n                    return SicOpAddrType.immediate;\n                case \"@\":\n                    return SicOpAddrType.indirect;\n                case \"=\":\n                default:\n                    return SicOpAddrType.direct;\n            }\n        };\n        var isLiteral = function (c) { return c !== undefined && c.charAt(0) === \"=\"; };\n        this.type = type;\n        this.base = this.type === SicOpType.f3 ? csect.base : undefined;\n        this.pcrel = this.type === SicOpType.f3;\n        var match;\n        if ((match = arg.match(reDecimal)) !== null) {\n            var x = parseInt(match[2], 10);\n            if (isLiteral(match[1])) {\n                csect.litTab.add(x);\n                this.val = new SicPending_1.SicPending(x);\n            }\n            else {\n                this.val = x;\n                this.pcrel = false;\n                this.base = undefined;\n            }\n        }\n        else if ((match = arg.match(reHex)) !== null) {\n            var x = parseInt(match[2], 16);\n            if (isLiteral(match[1])) {\n                csect.litTab.add(x);\n                this.val = new SicPending_1.SicPending(x);\n            }\n            else {\n                this.val = x;\n                this.pcrel = false;\n                this.base = undefined;\n            }\n        }\n        else if ((match = arg.match(reChar)) !== null) {\n            var bytes = [];\n            for (var i = 0; i < match[2].length; ++i) {\n                bytes.push(match[2].charCodeAt(i));\n            }\n            while (bytes.length < 3) {\n                bytes = [0].concat(bytes);\n            }\n            var x = (bytes[0] << 16) + (bytes[1] << 8) + (bytes[2]);\n            if (isLiteral(match[1])) {\n                csect.litTab.add(x);\n                this.val = new SicPending_1.SicPending(x);\n            }\n            else {\n                this.val = x;\n                this.pcrel = false;\n                this.base = undefined;\n            }\n        }\n        else if ((match = arg.match(reTag)) != null) {\n            if (csect.extRefTab.has(match[2])) {\n                if (this.type !== SicOpType.f4) {\n                    throw new Error(\"EXTREF symbols can only be used with format 4\");\n                }\n                csect.modRecs.push({ loc: csect.useTab.aloc, len: 5, symbol: match[2] });\n                this.val = 0;\n                this.pcrel = false;\n            }\n            else {\n                this.val = new SicPending_1.SicPending(match[2]);\n            }\n        }\n        else if (arg.trim() === \"\") {\n            this.val = 0;\n            this.pcrel = false;\n            this.base = undefined;\n            this.addr = SicOpAddrType.direct;\n            this.indexed = false;\n            this.rdy = true;\n            return;\n        }\n        else {\n            throw new Error(\"Operand \" + arg + \" is not of any valid format.\");\n        }\n        this.addr = getType(match[1]);\n        this.indexed = match[3] != null;\n        if (this.addr !== SicOpAddrType.direct && this.type === SicOpType.legacy) {\n            throw new Error(\"SIC Legacy instructions can only use direct addressing\");\n        }\n        this.rdy = !this.pcrel &&\n            this.base === undefined &&\n            typeof this.val === \"number\";\n    }\n    SicOperandAddr.prototype.ready = function () {\n        return this.rdy;\n    };\n    SicOperandAddr.prototype.makeReady = function (pc, tagTab, litTab, extRefTab) {\n        if (this.rdy) {\n            return null;\n        }\n        if (this.base !== undefined && !this.base.ready()) {\n            this.base.makeReady(tagTab);\n        }\n        if (typeof this.val !== \"number\") {\n            var q = this.val.convert(tagTab, litTab, extRefTab);\n            if (typeof q === \"string\") {\n                this.val = 0;\n                if (this.type !== SicOpType.f4) {\n                    throw new Error(\"EXTREF'd symbols can only be used with pass 2\");\n                }\n                return q;\n            }\n            this.val = q;\n        }\n        var opLen;\n        switch (this.type) {\n            case SicOpType.f3:\n                opLen = 12;\n                break;\n            case SicOpType.legacy:\n                opLen = 15;\n                break;\n            case SicOpType.f4:\n                opLen = 20;\n                break;\n            default:\n                throw new Error(\"type is not valid\");\n        }\n        if (this.pcrel) {\n            try {\n                this.val = SicUnsigned_1.sicMakeUnsigned(this.val - pc, opLen);\n                this.rdy = true;\n                return null;\n            }\n            catch (e) {\n                this.pcrel = false;\n            }\n        }\n        if (this.base) {\n            try {\n                this.val = SicUnsigned_1.sicMakeUnsigned(this.val - this.base.val, opLen);\n                this.rdy = true;\n                return null;\n            }\n            catch (e) {\n                this.base = undefined;\n            }\n        }\n        SicUnsigned_1.sicCheckUnsigned(this.val, opLen);\n        this.rdy = true;\n        return null;\n    };\n    SicOperandAddr.prototype.nixbpe = function () {\n        if (!this.ready()) {\n            throw new Error(\"nixbpe() can only be called when the value is ready.\");\n        }\n        var n;\n        var i;\n        var x = this.indexed;\n        var b = !this.pcrel && this.base !== undefined;\n        var p = this.pcrel;\n        var e = this.type === SicOpType.f4;\n        switch (this.addr) {\n            case SicOpAddrType.direct:\n                if (this.type === SicOpType.legacy) {\n                    n = false;\n                    i = false;\n                }\n                else {\n                    n = true;\n                    i = true;\n                }\n                break;\n            case SicOpAddrType.indirect:\n                n = true;\n                i = false;\n                break;\n            case SicOpAddrType.immediate:\n                n = false;\n                i = true;\n                break;\n            default:\n                throw new Error(\"Registers do not have an nixbpe value\");\n        }\n        var bytes = [0x0, 0x0];\n        if (n) {\n            bytes[0] |= 0x2;\n        }\n        if (i) {\n            bytes[0] |= 0x1;\n        }\n        if (x) {\n            bytes[1] |= 0x80;\n        }\n        if (b) {\n            bytes[1] |= 0x40;\n        }\n        if (p) {\n            bytes[1] |= 0x20;\n        }\n        if (e) {\n            bytes[1] |= 0x10;\n        }\n        return bytes;\n    };\n    return SicOperandAddr;\n}());\nexports.SicOperandAddr = SicOperandAddr;","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SicPending = (function () {\n    function SicPending(val) {\n        this.val = val;\n    }\n    SicPending.prototype.isLiteral = function () {\n        return typeof this.val === \"number\";\n    };\n    SicPending.prototype.isTag = function () {\n        return typeof this.val === \"string\";\n    };\n    SicPending.prototype.convert = function (tagTab, litTab, extRefTab) {\n        var s;\n        if (typeof this.val === \"number\") {\n            if (litTab === null) {\n                throw new Error(\"litTab is undefined but this SicPending is a literal\");\n            }\n            s = litTab.getLitLoc(this.val);\n            if (s === null) {\n                throw new Error(this.val + \"was not found in the literal table\");\n            }\n            return s;\n        }\n        if (extRefTab !== null && extRefTab.has(this.val)) {\n            return this.val;\n        }\n        if (tagTab === null) {\n            throw new Error(\"tagTab is undefined but this SicPending is a tag\");\n        }\n        s = tagTab[this.val];\n        if (s === null) {\n            throw new Error(this.val + \"was not found in the tag table\");\n        }\n        return s;\n    };\n    return SicPending;\n}());\nexports.SicPending = SicPending;","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.sicRegToDec = function (reg) {\n    switch (reg) {\n        case \"A\":\n            return 0;\n        case \"X\":\n            return 1;\n        case \"L\":\n            return 2;\n        case \"B\":\n            return 3;\n        case \"S\":\n            return 4;\n        case \"T\":\n            return 5;\n        case \"F\":\n            return 6;\n        case \"PC\":\n            return 8;\n        case \"SW\":\n            return 9;\n        default:\n            throw new Error(\"reg type \" + reg + \" is not valid\");\n    }\n};\nexports.sicDecToReg = function (reg) {\n    switch (reg) {\n        case 0:\n            return \"A\";\n        case 1:\n            return \"X\";\n        case 2:\n            return \"L\";\n        case 3:\n            return \"B\";\n        case 4:\n            return \"S\";\n        case 5:\n            return \"T\";\n        case 6:\n            return \"F\";\n        case 8:\n            return \"PC\";\n        case 9:\n            return \"SW\";\n        default:\n            throw new Error(\"reg no \" + reg + \" is not valid\");\n    }\n};","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SicUnsigned_1 = require(\"./SicUnsigned\");\nvar SicSpace = (function () {\n    function SicSpace(line) {\n        if (!SicSpace.isSpace(line.op)) {\n            throw new Error(\"This mnemonic is not a space.\");\n        }\n        this.mnemonic = line.op;\n        var func = this.mnemonic === \"BYTE\" ? SicSpace.splitByte : SicSpace.splitWord;\n        var reDec = new RegExp(\"^(-?\\\\d+)$\");\n        var reHex = new RegExp(\"^X'([0-9A-Fa-f]+)'$\");\n        var reChar = new RegExp(\"^C'(.+)'$\");\n        var match;\n        if ((match = line.args.match(reDec)) !== null) {\n            this.arg = func(parseInt(match[1], 10));\n        }\n        else if ((match = line.args.match(reHex)) !== null) {\n            this.arg = func(parseInt(match[1], 16));\n        }\n        else if ((match = line.args.match(reChar)) !== null) {\n            this.arg = [];\n            for (var i = 0; i < match[1].length; ++i) {\n                this.arg.push(match[1].charCodeAt(i));\n            }\n        }\n        else {\n            throw new Error(line.args + \" is not a valid operand format.\");\n        }\n    }\n    SicSpace.isSpace = function (mnemonic) {\n        var re = new RegExp(\"^(WORD|BYTE)$\");\n        return re.test(mnemonic);\n    };\n    SicSpace.splitWord = function (n) {\n        if (n >= 0) {\n            SicUnsigned_1.sicCheckUnsigned(n, 24);\n        }\n        else {\n            n = SicUnsigned_1.sicMakeUnsigned(n, 24);\n        }\n        return [(n & 0xFF0000) >>> 16, (n & 0xFF00) >>> 8, (n & 0xFF)];\n    };\n    SicSpace.splitByte = function (n) {\n        if (n >= 0) {\n            SicUnsigned_1.sicCheckUnsigned(n, 8);\n        }\n        else {\n            n = SicUnsigned_1.sicMakeUnsigned(n, 8);\n        }\n        return [0, 0, n];\n    };\n    SicSpace.prototype.ready = function () {\n        return true;\n    };\n    SicSpace.prototype.makeReady = function (loc, tagTab, litTab, extRefTab) {\n        return null;\n    };\n    SicSpace.prototype.length = function () {\n        switch (this.mnemonic) {\n            case \"WORD\":\n                return this.arg.length + (this.arg.length % 3 !== 0 ? 1 : 0);\n            case \"BYTE\":\n                return this.arg.length;\n            default:\n                throw new Error(this.mnemonic + \" is invalid. this is a ultra mega bug\");\n        }\n    };\n    SicSpace.prototype.toBytes = function () {\n        var a = [];\n        switch (this.mnemonic) {\n            case \"WORD\":\n                for (var i = 0; i < this.arg.length % 3; ++i) {\n                    a.push(0x00);\n                }\n                this.arg.forEach(function (val) { return a.push(val); });\n                return a;\n            case \"BYTE\":\n                return this.arg;\n            default:\n                throw new Error(\"Mnemonic is invalid.\");\n        }\n    };\n    return SicSpace;\n}());\nexports.SicSpace = SicSpace;","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SicSplit = (function () {\n    function SicSplit(line) {\n        line = line.replace(/\\..*$/, \"\").toUpperCase();\n        var lineArr = line.split(/\\s+/);\n        if (lineArr.length <= 1) {\n            throw new Error(\"This line does not have the correct number of entries. Did you forget to put whitespace before the operand?\");\n        }\n        this.tag = lineArr[0];\n        this.op = lineArr[1];\n        if (lineArr.length >= 3) {\n            this.args = lineArr.slice(2).reduce(function (acc, val) { return acc + val; }, \"\");\n        }\n        else {\n            this.args = \"\";\n        }\n        if (this.tag !== \"\" && this.tag.match(/^[A-Z][A-Z0-9]*$/) === null) {\n            throw new Error(\"Labels must start with A-Z (found \\\"\" + this.tag + \"\\\")\");\n        }\n    }\n    return SicSplit;\n}());\nexports.SicSplit = SicSplit;","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SicFmt_1 = require(\"./SicFmt\");\nexports.sicMakeMask = function (nBits) {\n    var m = 0x0;\n    for (var i = 0; i < nBits; ++i) {\n        m |= (1 << i);\n    }\n    return m;\n};\nexports.sicCheckUnsigned = function (val, nBits) {\n    if (val < 0x0 || val > exports.sicMakeMask(nBits)) {\n        throw new Error(SicFmt_1.asHex(val) + \" does not fit in an unsigned \" + nBits + \"-bit range\");\n    }\n};\nexports.sicMakeUnsigned = function (val, nBits) {\n    var m = exports.sicMakeMask(nBits - 1);\n    if (val < -m - 1 || val > m) {\n        throw new Error(SicFmt_1.asHex(val) + \" does not fit in a signed \" + nBits + \"-bit range\");\n    }\n    val >>>= 0;\n    val &= exports.sicMakeMask(nBits);\n    return val;\n};","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SicLocPair = (function () {\n    function SicLocPair(aloc, rloc) {\n        this.a = aloc;\n        this.r = rloc === undefined ? aloc : rloc;\n    }\n    return SicLocPair;\n}());\nexports.SicLocPair = SicLocPair;\nvar SicUseTab = (function () {\n    function SicUseTab(startloc) {\n        this.ALOC = startloc;\n        this.useTab = [{ label: \"\", rloc: startloc, locsent: [] }];\n        this.currentUse = 0;\n    }\n    Object.defineProperty(SicUseTab.prototype, \"aloc\", {\n        get: function () {\n            return this.ALOC;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SicUseTab.prototype, \"rloc\", {\n        get: function () {\n            return this.current.rloc;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    SicUseTab.prototype.loc = function () {\n        if (this.finalPair !== undefined) {\n            return this.finalPair;\n        }\n        var l = new SicLocPair(this.ALOC, this.current.rloc);\n        this.current.locsent.push(l);\n        return l;\n    };\n    SicUseTab.prototype.inc = function (n) {\n        this.current.rloc += n;\n        this.ALOC += n;\n    };\n    SicUseTab.prototype.use = function (label) {\n        var index = this.find(label);\n        if (index === null) {\n            this.useTab.push({ label: label, rloc: 0, locsent: [] });\n            this.currentUse = this.useTab.length - 1;\n        }\n        else {\n            this.currentUse = index;\n        }\n    };\n    SicUseTab.prototype.correct = function () {\n        if (this.finalPair !== undefined) {\n            return;\n        }\n        var prev = this.current.rloc;\n        for (var i = 1; i < this.useTab.length; ++i) {\n            this.useTab[i].locsent.forEach(function (l) { return l.r += prev; });\n            prev += this.useTab[i].rloc;\n        }\n        this.finalPair = new SicLocPair(this.aloc, prev);\n    };\n    SicUseTab.prototype.find = function (label) {\n        for (var i = 0; i < this.useTab.length; ++i) {\n            if (this.useTab[i].label === label) {\n                return i;\n            }\n        }\n        return null;\n    };\n    Object.defineProperty(SicUseTab.prototype, \"current\", {\n        get: function () {\n            return this.useTab[this.currentUse];\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return SicUseTab;\n}());\nexports.SicUseTab = SicUseTab;","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nrequire(\"jquery\");\nvar SicCompiler_1 = require(\"./SicCompiler/SicCompiler\");\nvar editor = ace.edit(\"editor\");\neditor.setTheme(\"ace/theme/monokai\");\neditor.session.setMode(\"ace/mode/sicxe\");\n$(\"#output\").val(\"\");\nvar textToArray = function (innerText) {\n    return innerText.split(\"\\n\");\n};\nvar arrayToText = function (array) {\n    return array.reduce(function (acc, val) { return acc + \"\\n\" + val; });\n};\n$(\"#btnCompile\").click(function () {\n    try {\n        var arr = textToArray(editor.getValue());\n        var comp = new SicCompiler_1.SicCompiler(arr);\n        var output = [\"-----lst-----\"];\n        output = output.concat(comp.makeLst());\n        if (!comp.err) {\n            output = output.concat(\"\", \"\", \"-----obj-----\");\n            output = output.concat(comp.makeObj());\n        }\n        else {\n            output = output.concat(\"\", \"\", \"No obj generation due to errors in lst.\");\n        }\n        $(\"#output\").val(arrayToText(output));\n    }\n    catch (e) {\n        alert(e.message);\n    }\n});"]}