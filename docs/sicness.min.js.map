{"version":3,"sources":["node_modules/browser-pack/_prelude.js","dist/SicCompiler/SicBase.js","dist/SicCompiler/SicBytecode.js","dist/SicCompiler/SicCompiler.js","dist/SicCompiler/SicCsect.js","dist/SicCompiler/SicFmt.js","dist/SicCompiler/SicFormat1.js","dist/SicCompiler/SicFormat2.js","dist/SicCompiler/SicFormat3.js","dist/SicCompiler/SicFormat4.js","dist/SicCompiler/SicFormatLegacy.js","dist/SicCompiler/SicLitTab.js","dist/SicCompiler/SicLiteral.js","dist/SicCompiler/SicLstEntry.js","dist/SicCompiler/SicOperandAddr.js","dist/SicCompiler/SicPending.js","dist/SicCompiler/SicRegConvert.js","dist/SicCompiler/SicSpace.js","dist/SicCompiler/SicSplit.js","dist/SicCompiler/SicUnsigned.js","dist/SicCompiler/SicUseTab.js","dist/app.js"],"names":["f","exports","module","define","amd","window","global","self","this","sicness","r","e","n","t","o","i","c","require","u","a","Error","code","p","call","length","1","Object","defineProperty","value","SicPending_1","SicBase","val","SicPending","prototype","ready","makeReady","tagTab","pending","convert","SicBytecode","mnemonic","opcode","format","mnemonicPvt","opcodePvt","formatPvt","get","enumerable","configurable","bytecodeTable","addBytecode","bc","writable","SicCsect_1","SicFormat1_1","SicFormat2_1","SicFormat3_1","SicFormat4_1","SicFormatLegacy_1","SicLstEntry_1","SicSpace_1","SicSplit_1","SicCompiler","lines","_this","ctab","SicCsectTab","errflag","forEach","replace","trim","split","SicSplit","instr","args","current","useTab","aloc","toString","_i","_a","keys","equTab","key","match","s","undefined","tag","isDirective","op","directives","SicFormat1","isFormat1","SicFormat2","isFormat2","SicFormat3","isFormat3","SicFormat4","isFormat4","SicFormatLegacy","isFormatLegacy","SicSpace","isSpace","addLst","SicLstEntry","rloc","inst","inc","message","litTab","hasPending","lst","l","bcData","makeLst","makeObj","default","SicBase_1","SicFmt_1","SicLiteral_1","SicLitTab_1","SicUseTab_1","SicCsect","startAddr","SicLitTab","SicUseTab","extDefTab","Set","extRefTab","modRecs","setStartAddr","currentSect","csects","parseNum","reDec","RegExp","reHex","reChar","parseInt","x","ptr","slice","charCodeAt","RESW","source","RESB","START","startData","name","loc","END","csect","BASE","base","NOBASE","LTORG","createOrg","v","asHex","SicLiteral","EQU","USE","use","CSECT","EXTDEF","add","EXTREF","has","push","concat","map","ls","astr","rstr","inststr","hasInstruction","byteString","istr","msg","padEnd","errmsg","mkH","len","asWord","mkD","defs","size","mkR","refs","mkT","arr","buf","asByte","bytesToString","toBytes","mkE","mkM","modrec","m","symbol","getLen","start","end","a_1","b","sloc","sname","forEachAux","filter","newSect","callback","curBuf","toUpperCase","padStart","reduce","acc","SicBytecode_1","line","SicRegConvert_1","SicUnsigned_1","matcher","str","reRegister","sicRegToDec","op1","sicCheckUnsigned","op2","bytes","SicOperandAddr_1","SicOperandAddr","SicOpType","f3","nixbpe","f4","charAt","legacy","ltorgs","getLitLoc","pc","diffMin","Number","MAX_SAFE_INTEGER","lt","Math","min","splitWord","byteCode","SicOpAddrType","arg","type","reDecimal","reTag","isLiteral","pcrel","addr","char","immediate","indirect","direct","getType","indexed","rdy","opLen","sicMakeUnsigned","isTag","reg","sicDecToReg","func","splitByte","test","lineArr","sicMakeMask","nBits","startloc","ALOC","RLOC","currentUse","label","__importDefault","mod","__esModule","SicCompiler_1","editor","ace","edit","setTheme","session","setMode","$","click","getValue","comp","output","err","alert"],"mappings":"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","file":"sicness.min.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SicPending_1 = require(\"./SicPending\");\nvar SicBase = (function () {\n    function SicBase(val) {\n        this.val = val;\n        if (this.val instanceof SicPending_1.SicPending && typeof this.val.val === \"number\") {\n            this.val = this.val.val;\n        }\n    }\n    SicBase.prototype.ready = function () {\n        return typeof this.val === \"number\";\n    };\n    SicBase.prototype.makeReady = function (p) {\n        if (typeof this.val === \"number\") {\n            return;\n        }\n        if (typeof p === \"number\") {\n            this.val = p;\n            return;\n        }\n        var tagTab = p;\n        var pending = this.val;\n        this.val = pending.convert(tagTab, null);\n    };\n    return SicBase;\n}());\nexports.SicBase = SicBase;","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SicBytecode = (function () {\n    function SicBytecode(mnemonic, opcode, format) {\n        this.mnemonicPvt = mnemonic;\n        this.opcodePvt = opcode;\n        this.formatPvt = format;\n    }\n    Object.defineProperty(SicBytecode.prototype, \"mnemonic\", {\n        get: function () {\n            return this.mnemonicPvt;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SicBytecode.prototype, \"opcode\", {\n        get: function () {\n            return this.opcodePvt;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SicBytecode.prototype, \"format\", {\n        get: function () {\n            return this.formatPvt;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return SicBytecode;\n}());\nexports.SicBytecode = SicBytecode;\nexports.bytecodeTable = {};\nvar addBytecode = function (bc) {\n    Object.defineProperty(exports.bytecodeTable, bc.mnemonic, {\n        configurable: true,\n        enumerable: true,\n        value: bc,\n        writable: false,\n    });\n};\naddBytecode(new SicBytecode(\"ADD\", 0x18, 3));\naddBytecode(new SicBytecode(\"ADDF\", 0x58, 3));\naddBytecode(new SicBytecode(\"ADDR\", 0x90, 2));\naddBytecode(new SicBytecode(\"AND\", 0x40, 3));\naddBytecode(new SicBytecode(\"CLEAR\", 0xB4, 2));\naddBytecode(new SicBytecode(\"COMP\", 0x28, 3));\naddBytecode(new SicBytecode(\"COMPF\", 0x88, 3));\naddBytecode(new SicBytecode(\"COMPR\", 0xA0, 2));\naddBytecode(new SicBytecode(\"DIV\", 0x24, 3));\naddBytecode(new SicBytecode(\"DIVF\", 0x64, 3));\naddBytecode(new SicBytecode(\"DIVR\", 0x9C, 2));\naddBytecode(new SicBytecode(\"FIX\", 0xC4, 1));\naddBytecode(new SicBytecode(\"FLOAT\", 0xC0, 1));\naddBytecode(new SicBytecode(\"HIO\", 0xF4, 1));\naddBytecode(new SicBytecode(\"J\", 0x3C, 3));\naddBytecode(new SicBytecode(\"JEQ\", 0x30, 3));\naddBytecode(new SicBytecode(\"JGT\", 0x34, 3));\naddBytecode(new SicBytecode(\"JLT\", 0x38, 3));\naddBytecode(new SicBytecode(\"JSUB\", 0x48, 3));\naddBytecode(new SicBytecode(\"LDA\", 0x00, 3));\naddBytecode(new SicBytecode(\"LDB\", 0x68, 3));\naddBytecode(new SicBytecode(\"LDCH\", 0x50, 3));\naddBytecode(new SicBytecode(\"LDF\", 0x70, 3));\naddBytecode(new SicBytecode(\"LDL\", 0x08, 3));\naddBytecode(new SicBytecode(\"LDS\", 0x6C, 3));\naddBytecode(new SicBytecode(\"LDT\", 0x74, 3));\naddBytecode(new SicBytecode(\"LDX\", 0x04, 3));\naddBytecode(new SicBytecode(\"LPS\", 0xD0, 3));\naddBytecode(new SicBytecode(\"MUL\", 0x20, 3));\naddBytecode(new SicBytecode(\"MULF\", 0x60, 3));\naddBytecode(new SicBytecode(\"MULR\", 0x98, 2));\naddBytecode(new SicBytecode(\"NORM\", 0xC8, 1));\naddBytecode(new SicBytecode(\"OR\", 0x44, 3));\naddBytecode(new SicBytecode(\"RD\", 0xD8, 3));\naddBytecode(new SicBytecode(\"RMO\", 0xAC, 2));\naddBytecode(new SicBytecode(\"RSUB\", 0x4C, 3));\naddBytecode(new SicBytecode(\"SHIFTL\", 0xA4, 2));\naddBytecode(new SicBytecode(\"SHIFTR\", 0xA8, 2));\naddBytecode(new SicBytecode(\"SIO\", 0xF0, 1));\naddBytecode(new SicBytecode(\"SSK\", 0xEC, 3));\naddBytecode(new SicBytecode(\"STA\", 0x0C, 3));\naddBytecode(new SicBytecode(\"STB\", 0x78, 3));\naddBytecode(new SicBytecode(\"STCH\", 0x54, 3));\naddBytecode(new SicBytecode(\"STF\", 0x80, 3));\naddBytecode(new SicBytecode(\"STI\", 0xD4, 3));\naddBytecode(new SicBytecode(\"STL\", 0x14, 3));\naddBytecode(new SicBytecode(\"STS\", 0x7C, 3));\naddBytecode(new SicBytecode(\"STSW\", 0xE8, 3));\naddBytecode(new SicBytecode(\"STT\", 0x84, 3));\naddBytecode(new SicBytecode(\"STX\", 0x10, 3));\naddBytecode(new SicBytecode(\"SUB\", 0x1C, 3));\naddBytecode(new SicBytecode(\"SUBF\", 0x5C, 3));\naddBytecode(new SicBytecode(\"SUBR\", 0x94, 2));\naddBytecode(new SicBytecode(\"SVC\", 0xB0, 2));\naddBytecode(new SicBytecode(\"TD\", 0xE0, 3));\naddBytecode(new SicBytecode(\"TIO\", 0xF8, 1));\naddBytecode(new SicBytecode(\"TIX\", 0x2C, 3));\naddBytecode(new SicBytecode(\"TIXR\", 0xB8, 2));\naddBytecode(new SicBytecode(\"WD\", 0xDC, 3));","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SicCsect_1 = require(\"./SicCsect\");\nvar SicFormat1_1 = require(\"./SicFormat1\");\nvar SicFormat2_1 = require(\"./SicFormat2\");\nvar SicFormat3_1 = require(\"./SicFormat3\");\nvar SicFormat4_1 = require(\"./SicFormat4\");\nvar SicFormatLegacy_1 = require(\"./SicFormatLegacy\");\nvar SicLstEntry_1 = require(\"./SicLstEntry\");\nvar SicSpace_1 = require(\"./SicSpace\");\nvar SicSplit_1 = require(\"./SicSplit\");\nvar SicCompiler = (function () {\n    function SicCompiler(lines) {\n        var _this = this;\n        this.ctab = new SicCsect_1.SicCsectTab();\n        this.errflag = false;\n        lines.forEach(function (val) {\n            try {\n                if (val.replace(/\\..*$/, \"\").trim() === \"\") {\n                    return;\n                }\n                var split = new SicSplit_1.SicSplit(val);\n                var instr = void 0;\n                split.args.replace(/(#|@|=)\\*$/, \"$1\" + _this.ctab.current.useTab.aloc.toString(10));\n                for (var _i = 0, _a = Object.keys(_this.ctab.current.equTab); _i < _a.length; _i++) {\n                    var key = _a[_i];\n                    if (split.args.match(key) === null) {\n                        continue;\n                    }\n                    for (var s = _this.ctab.current.equTab[key]; s !== undefined; s = _this.ctab.current.equTab[s]) {\n                        split.args = split.args.replace(key, _this.ctab.current.equTab[key]);\n                    }\n                    break;\n                }\n                if (split.tag !== \"\") {\n                    if (_this.ctab.current.tagTab[split.tag] !== undefined) {\n                        throw new Error(\"Duplicate label \" + split.tag);\n                    }\n                    _this.ctab.current.tagTab[split.tag] = _this.ctab.current.useTab.aloc;\n                }\n                if (_this.ctab.isDirective(split.op)) {\n                    _this.ctab.directives[split.op](val, split);\n                    return;\n                }\n                if (SicFormat1_1.SicFormat1.isFormat1(split.op)) {\n                    instr = new SicFormat1_1.SicFormat1(split);\n                }\n                else if (SicFormat2_1.SicFormat2.isFormat2(split.op)) {\n                    instr = new SicFormat2_1.SicFormat2(split);\n                }\n                else if (SicFormat3_1.SicFormat3.isFormat3(split.op)) {\n                    instr = new SicFormat3_1.SicFormat3(split, _this.ctab.current);\n                }\n                else if (SicFormat4_1.SicFormat4.isFormat4(split.op)) {\n                    instr = new SicFormat4_1.SicFormat4(split, _this.ctab.current);\n                }\n                else if (SicFormatLegacy_1.SicFormatLegacy.isFormatLegacy(split.op)) {\n                    instr = new SicFormatLegacy_1.SicFormatLegacy(split, _this.ctab.current);\n                }\n                else if (SicSpace_1.SicSpace.isSpace(split.op)) {\n                    instr = new SicSpace_1.SicSpace(split);\n                }\n                else {\n                    throw new Error(split.op + \" is not a valid mnemonic.\");\n                }\n                _this.ctab.addLst(new SicLstEntry_1.SicLstEntry(val, { aloc: _this.ctab.current.useTab.aloc, rloc: _this.ctab.current.useTab.rloc, inst: instr }));\n                _this.ctab.current.useTab.inc(instr.length());\n            }\n            catch (e) {\n                _this.errflag = true;\n                _this.ctab.addLst(new SicLstEntry_1.SicLstEntry(val, e.message));\n            }\n        });\n        this.ctab.forEach(function (p) {\n            if (p.litTab.hasPending()) {\n                _this.ctab.directives[\"LTORG\"](\"AUTO-LTORG\", new SicSplit_1.SicSplit(\"\\tAUTO-LTORG\"));\n            }\n        });\n        this.ctab.forEach(function (p) {\n            p.lst.forEach(function (l) {\n                if (l.bcData !== undefined && l.bcData.inst !== undefined && !l.bcData.inst.ready()) {\n                    l.bcData.inst.makeReady(l.bcData.aloc, p.tagTab, p.litTab);\n                }\n            });\n        });\n    }\n    SicCompiler.prototype.makeLst = function () {\n        return this.ctab.makeLst();\n    };\n    SicCompiler.prototype.makeObj = function () {\n        return this.ctab.makeObj();\n    };\n    Object.defineProperty(SicCompiler.prototype, \"err\", {\n        get: function () {\n            return this.errflag;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return SicCompiler;\n}());\nexports.default = SicCompiler;","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SicBase_1 = require(\"./SicBase\");\nvar SicFmt_1 = require(\"./SicFmt\");\nvar SicLiteral_1 = require(\"./SicLiteral\");\nvar SicLitTab_1 = require(\"./SicLitTab\");\nvar SicLstEntry_1 = require(\"./SicLstEntry\");\nvar SicPending_1 = require(\"./SicPending\");\nvar SicUseTab_1 = require(\"./SicUseTab\");\nvar SicCsect = (function () {\n    function SicCsect(startAddr) {\n        this.lst = [];\n        this.litTab = new SicLitTab_1.SicLitTab();\n        this.tagTab = {};\n        this.equTab = {};\n        this.useTab = new SicUseTab_1.SicUseTab(startAddr);\n        this.extDefTab = new Set();\n        this.extRefTab = new Set();\n        this.modRecs = [];\n    }\n    SicCsect.prototype.setStartAddr = function (startAddr) {\n        this.useTab = new SicUseTab_1.SicUseTab(startAddr);\n    };\n    return SicCsect;\n}());\nexports.SicCsect = SicCsect;\nvar SicCsectTab = (function () {\n    function SicCsectTab() {\n        var _this = this;\n        this.currentSect = \"\";\n        this.csects = {};\n        this.csects[this.currentSect] = new SicCsect(0);\n        this.lst = [];\n        var parseNum = function (val) {\n            var reDec = new RegExp(\"^(\\\\d+)$\");\n            var reHex = new RegExp(\"^X'([0-9A-Fa-f]+)'$\");\n            var reChar = new RegExp(\"^C'.{1,3}'$\");\n            var match;\n            if ((match = val.match(reDec)) !== null) {\n                return parseInt(match[1], 10);\n            }\n            if ((match = val.match(reHex)) !== null) {\n                return parseInt(match[1], 16);\n            }\n            if ((match = val.match(reChar)) !== null) {\n                var x = 0;\n                for (var ptr = 0, s = match[1]; s !== \"\"; ptr += 8, s = s.slice(0, -1)) {\n                    x += s.charCodeAt(s.length - 1) << ptr;\n                }\n                return x;\n            }\n            throw new Error(val + \" was not of a valid numeric format.\");\n        };\n        this.directives = {\n            RESW: function (source, split) {\n                _this.addLst(new SicLstEntry_1.SicLstEntry(source, { aloc: _this.current.useTab.aloc, rloc: _this.current.useTab.rloc, inst: undefined }));\n                _this.current.useTab.inc(3 * parseNum(split.args));\n            },\n            RESB: function (source, split) {\n                _this.addLst(new SicLstEntry_1.SicLstEntry(source, { aloc: _this.current.useTab.aloc, rloc: _this.current.useTab.rloc, inst: undefined }));\n                _this.current.useTab.inc(parseNum(split.args));\n            },\n            START: function (source, split) {\n                if (_this.currentSect !== \"\" || _this.current.lst.length !== 0) {\n                    throw new Error(\"START can only be used as the first line of a program.\");\n                }\n                _this.current.setStartAddr(parseInt(split.args, 16));\n                _this.addLst(new SicLstEntry_1.SicLstEntry(source, { aloc: _this.current.useTab.aloc, rloc: _this.current.useTab.rloc, inst: undefined }));\n                _this.startData = { name: split.tag, loc: _this.current.useTab.aloc };\n            },\n            END: function (source, split) {\n                _this.csect(\"\");\n                if ((_this.startData === undefined && split.args !== \"\") ||\n                    (_this.startData !== undefined && split.args !== _this.startData.name)) {\n                    throw new Error(\"END label must be the same as the start label.\");\n                }\n                _this.addLst(new SicLstEntry_1.SicLstEntry(source, { aloc: _this.current.useTab.aloc, rloc: _this.current.useTab.rloc, inst: undefined }));\n            },\n            BASE: function (source, split) {\n                try {\n                    _this.current.base = new SicBase_1.SicBase(parseNum(split.args));\n                }\n                catch (e) {\n                    _this.current.base = new SicBase_1.SicBase(new SicPending_1.SicPending(split.args));\n                }\n                _this.addLst(new SicLstEntry_1.SicLstEntry(source));\n            },\n            NOBASE: function (source, split) {\n                _this.current.base = undefined;\n                _this.addLst(new SicLstEntry_1.SicLstEntry(source));\n            },\n            LTORG: function (source, split) {\n                _this.addLst(new SicLstEntry_1.SicLstEntry(source));\n                var l = _this.current.litTab.createOrg(_this.current.useTab.aloc);\n                l.forEach(function (v) {\n                    _this.addLst(new SicLstEntry_1.SicLstEntry(\"LTORG-WORD X'\" + SicFmt_1.asHex(v.val) + \"'\", { aloc: _this.current.useTab.aloc, rloc: _this.current.useTab.rloc, inst: new SicLiteral_1.SicLiteral(v.val) }));\n                    _this.current.useTab.inc(3);\n                });\n            },\n            EQU: function (source, split) {\n                if (split.tag === \"\") {\n                    throw new Error(\"EQU needs a non-empty label.\");\n                }\n                if (_this.current.equTab[split.args] !== undefined) {\n                    throw new Error(\"EQU \" + split.args + \" was already defined.\");\n                }\n                _this.current.equTab[split.tag] = split.args;\n                _this.addLst(new SicLstEntry_1.SicLstEntry(source));\n            },\n            USE: function (source, split) {\n                _this.current.useTab.use(split.args);\n                _this.addLst(new SicLstEntry_1.SicLstEntry(source));\n            },\n            CSECT: function (source, split) {\n                _this.addLst(new SicLstEntry_1.SicLstEntry(source));\n                _this.csect(split.tag);\n            },\n            EXTDEF: function (source, split) {\n                var s = split.args.split(\",\");\n                _this.addLst(new SicLstEntry_1.SicLstEntry(source));\n                s.forEach(function (r) {\n                    if (_this.current.tagTab[r] === undefined) {\n                        throw new Error(r + \" does not exist in the symbol table. Did you try to forward reference it?\");\n                    }\n                    _this.current.extDefTab.add(r);\n                });\n            },\n            EXTREF: function (source, split) {\n                var s = split.args.split(\",\");\n                _this.addLst(new SicLstEntry_1.SicLstEntry(source));\n                s.forEach(function (r) {\n                    if (_this.current.extRefTab.has(r)) {\n                        throw new Error(\"Duplicate EXTREF \" + r);\n                    }\n                    if (_this.current.tagTab[r] !== undefined) {\n                        throw new Error(\"Duplicate label \" + r);\n                    }\n                    _this.current.extRefTab.add(r);\n                });\n            },\n        };\n    }\n    SicCsectTab.prototype.isDirective = function (mnemonic) {\n        return this.directives[mnemonic] !== undefined;\n    };\n    SicCsectTab.prototype.addLst = function (l) {\n        this.lst.push(l);\n        this.current.lst.push(l);\n    };\n    SicCsectTab.prototype.makeLst = function () {\n        var s = [\"n\"];\n        s[0] = \"n    \\taloc \\trloc \\tbytecode\\tsource\";\n        s[1] = \"-----\\t-----\\t-----\\t--------\\t------\";\n        var i = 1;\n        return s.concat(this.lst.map(function (ls) {\n            var astr = ls.bcData === undefined ? \"\" : SicFmt_1.asHex(ls.bcData.aloc);\n            var rstr = ls.bcData === undefined ? \"\" : SicFmt_1.asHex(ls.bcData.rloc);\n            var inststr = ls.hasInstruction() ? ls.byteString() : \"\";\n            var istr = i.toString(10);\n            ++i;\n            var msg = istr.padEnd(5, \" \") + \"\\t\" +\n                astr.padEnd(5, \" \") + \"\\t\" +\n                rstr.padEnd(5, \" \") + \"\\t\" +\n                inststr.padEnd(8, \" \") + \"\\t\" +\n                ls.source;\n            if (ls.errmsg !== undefined) {\n                msg += \"\\n* Error: \" + ls.errmsg + \" *\";\n            }\n            return msg;\n        }));\n    };\n    SicCsectTab.prototype.makeObj = function () {\n        var s = [];\n        var mkH = function (len, loc, name) {\n            if (loc === undefined) {\n                loc = 0;\n            }\n            if (name === undefined) {\n                name = \"\";\n            }\n            return \"H \" + name + \" \" + SicFmt_1.asWord(loc) + \" \" + SicFmt_1.asWord(len);\n        };\n        var mkD = function (defs, tagTab) {\n            if (defs.size === 0) {\n                return \"\";\n            }\n            var a = \"D \";\n            defs.forEach(function (v) { return a += v + \" \" + SicFmt_1.asWord(tagTab[v]); }, \"\");\n            return a;\n        };\n        var mkR = function (refs) {\n            if (refs.size === 0) {\n                return \"\";\n            }\n            var a = \"R \";\n            refs.forEach(function (v) { return a += v + \" \"; }, \"\");\n            return a.trim();\n        };\n        var mkT = function (arr) {\n            var buf = [];\n            arr.forEach(function (l) {\n                if (l.bcData === undefined || l.bcData.inst === undefined) {\n                    return;\n                }\n                buf.push(\"T \" + SicFmt_1.asWord(l.bcData.aloc) + \" \" + SicFmt_1.asByte(l.bcData.inst.length()) + \" \" + SicFmt_1.bytesToString(l.bcData.inst.toBytes()));\n            });\n            return buf;\n        };\n        var mkE = function (loc) {\n            if (loc === undefined) {\n                return \"E\";\n            }\n            return \"E \" + SicFmt_1.asWord(loc);\n        };\n        var mkM = function (modrec) {\n            return modrec.map(function (m) {\n                return \"M \" + SicFmt_1.asWord(m.loc) + \" \" + SicFmt_1.asByte(m.len) + \" +\" + m.symbol;\n            });\n        };\n        var getLen = function (a) {\n            var start = 0;\n            var end = 0;\n            for (var _i = 0, a_1 = a; _i < a_1.length; _i++) {\n                var b = a_1[_i];\n                if (b.bcData !== undefined) {\n                    start = b.bcData.aloc;\n                    break;\n                }\n            }\n            for (var i = a.length - 1; i >= 0; --i) {\n                var bc = a[i].bcData;\n                if (bc !== undefined) {\n                    end = bc.aloc + (bc.inst !== undefined ? bc.inst.length() : 0);\n                    break;\n                }\n            }\n            return end - start;\n        };\n        var sloc = this.startData !== undefined ? this.startData.loc : 0;\n        var sname = this.startData !== undefined ? this.startData.name : \"\";\n        s.push(mkH(getLen(this.csects[\"\"].lst), sloc, sname));\n        s.push(mkD(this.csects[\"\"].extDefTab, this.csects[\"\"].tagTab));\n        s.push(mkR(this.csects[\"\"].extRefTab));\n        s = s.concat(mkT(this.csects[\"\"].lst));\n        s = s.concat(mkM(this.csects[\"\"].modRecs));\n        s.push(mkE(sloc));\n        this.forEachAux(function (c, n) {\n            s.push(mkH(getLen(c.lst), 0, n));\n            s.push(mkD(c.extDefTab, c.tagTab));\n            s.push(mkR(c.extRefTab));\n            s = s.concat(mkT(c.lst));\n            s = s.concat(mkM(c.modRecs));\n            s.push(mkE());\n        });\n        return s.filter(function (r) { return r !== \"\"; });\n    };\n    Object.defineProperty(SicCsectTab.prototype, \"current\", {\n        get: function () {\n            return this.csects[this.currentSect];\n        },\n        enumerable: true,\n        configurable: true\n    });\n    SicCsectTab.prototype.csect = function (newSect) {\n        this.currentSect = newSect;\n        if (this.csects[this.currentSect] === undefined) {\n            this.csects[this.currentSect] = new SicCsect(0);\n        }\n    };\n    Object.defineProperty(SicCsectTab.prototype, \"default\", {\n        get: function () {\n            return this.csects[\"\"];\n        },\n        enumerable: true,\n        configurable: true\n    });\n    SicCsectTab.prototype.forEach = function (callback) {\n        var _this = this;\n        var curBuf = this.currentSect;\n        Object.keys(this.csects).forEach(function (c) {\n            _this.currentSect = c;\n            callback(_this.csects[c], c);\n        });\n        this.currentSect = curBuf;\n    };\n    SicCsectTab.prototype.forEachAux = function (callback) {\n        var _this = this;\n        var curBuf = this.currentSect;\n        Object.keys(this.csects).forEach(function (c) {\n            if (c === \"\") {\n                return;\n            }\n            _this.currentSect = c;\n            callback(_this.csects[c], c);\n        });\n        this.currentSect = curBuf;\n    };\n    return SicCsectTab;\n}());\nexports.SicCsectTab = SicCsectTab;","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.asHex = function (n) { return n.toString(16).toUpperCase(); };\nexports.asWord = function (n) { return exports.asHex(n).padStart(6, \"0\"); };\nexports.asByte = function (n) { return exports.asHex(n).padStart(2, \"0\"); };\nexports.bytesToString = function (n) { return n.reduce(function (acc, val) { return acc + exports.asByte(val); }, \"\"); };","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SicBytecode_1 = require(\"./SicBytecode\");\nvar SicFormat1 = (function () {\n    function SicFormat1(line) {\n        if (!SicFormat1.isFormat1(line.op)) {\n            throw new Error(line.op + \" is not a format 1 operation\");\n        }\n        if (line.args !== \"\") {\n            throw new Error(\"Format 1 arguments cannot have arguments\");\n        }\n        this.bc = SicBytecode_1.bytecodeTable[line.op];\n    }\n    SicFormat1.isFormat1 = function (mnemonic) {\n        var bc = SicBytecode_1.bytecodeTable[mnemonic];\n        return bc !== undefined && bc.format === 1;\n    };\n    SicFormat1.prototype.ready = function () {\n        return true;\n    };\n    SicFormat1.prototype.makeReady = function (loc, tagTab, litTab) {\n        return;\n    };\n    SicFormat1.prototype.length = function () {\n        return 1;\n    };\n    SicFormat1.prototype.toBytes = function () {\n        return [this.bc.opcode];\n    };\n    return SicFormat1;\n}());\nexports.SicFormat1 = SicFormat1;","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SicBytecode_1 = require(\"./SicBytecode\");\nvar SicRegConvert_1 = require(\"./SicRegConvert\");\nvar SicUnsigned_1 = require(\"./SicUnsigned\");\nvar SicFormat2 = (function () {\n    function SicFormat2(line) {\n        if (!SicFormat2.isFormat2(line.op)) {\n            throw new Error(line.op + \" is not a format 2 opcode\");\n        }\n        this.bc = SicBytecode_1.bytecodeTable[line.op];\n        var s = line.args.trim().split(/\\s*,\\s*/);\n        if (s.length === 1) {\n            s.push(\"0\");\n        }\n        if (s.length !== 2) {\n            throw new Error(\"This format 2 instruction has an invalid number of operands.\");\n        }\n        var matcher = function (str) {\n            var reRegister = new RegExp(\"^(A|X|L|PC|SW|B|S|T|F)$\");\n            var reHex = new RegExp(\"^X'([0-9A-Fa-f]+)'$\");\n            var reDec = new RegExp(\"^([0-9]+)$\");\n            var match;\n            if ((match = str.match(reRegister)) !== null) {\n                return SicRegConvert_1.sicRegToDec(match[1]);\n            }\n            else if ((match = str.match(reHex)) !== null) {\n                return parseInt(match[1], 16);\n            }\n            else if ((match = str.match(reDec)) !== null) {\n                return parseInt(match[1], 10);\n            }\n            throw new Error(str + \" is not a valid format 2 operand.\");\n        };\n        this.op1 = matcher(s[0]);\n        SicUnsigned_1.sicCheckUnsigned(this.op1, 4);\n        this.op2 = matcher(s[1]);\n        SicUnsigned_1.sicCheckUnsigned(this.op2, 4);\n    }\n    SicFormat2.isFormat2 = function (mnemonic) {\n        var bc = SicBytecode_1.bytecodeTable[mnemonic];\n        return bc !== undefined && bc.format === 2;\n    };\n    SicFormat2.prototype.ready = function () {\n        return true;\n    };\n    SicFormat2.prototype.makeReady = function (loc, tagTab, litTab) {\n        return;\n    };\n    SicFormat2.prototype.length = function () {\n        return 2;\n    };\n    SicFormat2.prototype.toBytes = function () {\n        var bytes = [0x00, 0x00];\n        bytes[0] = this.bc.opcode;\n        bytes[1] |= (this.op1 & 0x0F) << 4;\n        bytes[1] |= (this.op2 & 0x0F);\n        return bytes;\n    };\n    return SicFormat2;\n}());\nexports.SicFormat2 = SicFormat2;","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SicBytecode_1 = require(\"./SicBytecode\");\nvar SicOperandAddr_1 = require(\"./SicOperandAddr\");\nvar SicFormat3 = (function () {\n    function SicFormat3(line, csect) {\n        if (!SicFormat3.isFormat3(line.op)) {\n            throw new Error(line.op + \" is not format 3\");\n        }\n        this.bc = SicBytecode_1.bytecodeTable[line.op];\n        this.op = new SicOperandAddr_1.SicOperandAddr(line.args, SicOperandAddr_1.SicOpType.f3, csect);\n    }\n    SicFormat3.isFormat3 = function (mnemonic) {\n        var bc = SicBytecode_1.bytecodeTable[mnemonic];\n        return bc !== undefined && bc.format === 3;\n    };\n    SicFormat3.prototype.makeReady = function (loc, tagTab, litTab) {\n        this.op.makeReady(loc + 3, tagTab, litTab);\n    };\n    SicFormat3.prototype.ready = function () {\n        return this.op.ready();\n    };\n    SicFormat3.prototype.length = function () {\n        return 3;\n    };\n    SicFormat3.prototype.toBytes = function () {\n        if (!this.ready()) {\n            throw new Error(\"Internal error: This SicFormat3 instruction is not ready.\");\n        }\n        var bytes = this.op.nixbpe();\n        bytes[0] |= (this.bc.opcode & 0xFC);\n        bytes[1] |= (this.op.val & 0x0F00) >>> 8;\n        bytes[2] = (this.op.val & 0xFF);\n        return bytes;\n    };\n    return SicFormat3;\n}());\nexports.SicFormat3 = SicFormat3;","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SicBytecode_1 = require(\"./SicBytecode\");\nvar SicOperandAddr_1 = require(\"./SicOperandAddr\");\nvar SicFormat4 = (function () {\n    function SicFormat4(line, csect) {\n        if (!SicFormat4.isFormat4(line.op)) {\n            throw new Error(line.op + \" is not format 4\");\n        }\n        this.bc = SicBytecode_1.bytecodeTable[line.op.slice(1)];\n        this.op = new SicOperandAddr_1.SicOperandAddr(line.args, SicOperandAddr_1.SicOpType.f4, csect);\n    }\n    SicFormat4.isFormat4 = function (mnemonic) {\n        if (mnemonic.charAt(0) !== \"+\") {\n            return false;\n        }\n        var bc = SicBytecode_1.bytecodeTable[mnemonic.slice(1)];\n        return bc !== undefined && bc.format === 3;\n    };\n    SicFormat4.prototype.makeReady = function (loc, tagTab, litTab) {\n        this.op.makeReady(loc + this.length(), tagTab, litTab);\n    };\n    SicFormat4.prototype.ready = function () {\n        return this.op.ready();\n    };\n    SicFormat4.prototype.length = function () {\n        return 4;\n    };\n    SicFormat4.prototype.toBytes = function () {\n        if (!this.ready()) {\n            throw new Error(\"Internal error: This SicFormat4 instruction is not ready.\");\n        }\n        var bytes = this.op.nixbpe();\n        bytes[0] |= (this.bc.opcode & 0xFC);\n        bytes[1] |= (this.op.val & 0x0F0000) >>> 16;\n        bytes[2] = (this.op.val & 0xFF00) >>> 8;\n        bytes[3] = (this.op.val & 0xFF);\n        return bytes;\n    };\n    return SicFormat4;\n}());\nexports.SicFormat4 = SicFormat4;","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SicBytecode_1 = require(\"./SicBytecode\");\nvar SicOperandAddr_1 = require(\"./SicOperandAddr\");\nvar SicFormatLegacy = (function () {\n    function SicFormatLegacy(line, csect) {\n        if (!SicFormatLegacy.isFormatLegacy(line.op)) {\n            throw new Error(line.op + \" is not SIC legacy format\");\n        }\n        this.bc = SicBytecode_1.bytecodeTable[line.op.slice(1)];\n        this.op = new SicOperandAddr_1.SicOperandAddr(line.args, SicOperandAddr_1.SicOpType.legacy, csect);\n    }\n    SicFormatLegacy.isFormatLegacy = function (mnemonic) {\n        if (mnemonic.charAt(0) !== \"*\") {\n            return false;\n        }\n        var bc = SicBytecode_1.bytecodeTable[mnemonic.slice(1)];\n        return bc !== undefined && bc.format === 3;\n    };\n    SicFormatLegacy.prototype.makeReady = function (loc, tagTab, litTab) {\n        this.op.makeReady(loc + this.length(), tagTab, litTab);\n    };\n    SicFormatLegacy.prototype.ready = function () {\n        return this.op.ready();\n    };\n    SicFormatLegacy.prototype.length = function () {\n        return 3;\n    };\n    SicFormatLegacy.prototype.toBytes = function () {\n        if (!this.ready()) {\n            throw new Error(\"Internal error: This SicFormatLegacy instruction is not ready.\");\n        }\n        var bytes = this.op.nixbpe();\n        bytes[0] |= (this.bc.opcode & 0xFC);\n        bytes[1] |= (this.op.val & 0x7F00) >>> 8;\n        bytes[2] = (this.op.val & 0xFF);\n        return bytes;\n    };\n    return SicFormatLegacy;\n}());\nexports.SicFormatLegacy = SicFormatLegacy;","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SicLitTab = (function () {\n    function SicLitTab() {\n        this.ltorgs = [];\n        this.pending = new Set();\n    }\n    SicLitTab.prototype.getLitLoc = function (n, pc) {\n        if (pc === void 0) { pc = 0; }\n        var diffMin = Number.MAX_SAFE_INTEGER;\n        var loc = null;\n        this.ltorgs.forEach(function (lt) {\n            if (lt.val === n && diffMin > Math.min(lt.loc - pc, lt.loc)) {\n                diffMin = Math.min(lt.loc - pc, lt.loc);\n                loc = lt.loc;\n            }\n        });\n        return loc;\n    };\n    SicLitTab.prototype.createOrg = function (loc) {\n        var l = loc;\n        var m = [];\n        var lt = this.pending.forEach(function (v) {\n            m.push({ loc: l, val: v });\n            l += 3;\n        });\n        this.ltorgs = this.ltorgs.concat(m);\n        this.pending = new Set();\n        return m;\n    };\n    SicLitTab.prototype.add = function (n) {\n        if (this.getLitLoc(n) === null) {\n            this.pending.add(n);\n        }\n    };\n    SicLitTab.prototype.hasPending = function (n) {\n        if (n === undefined) {\n            return this.pending.size > 0;\n        }\n        return this.pending.has(n);\n    };\n    return SicLitTab;\n}());\nexports.SicLitTab = SicLitTab;","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SicSpace_1 = require(\"./SicSpace\");\nvar SicLiteral = (function () {\n    function SicLiteral(val) {\n        this.val = val;\n    }\n    SicLiteral.prototype.length = function () {\n        return 3;\n    };\n    SicLiteral.prototype.ready = function () {\n        return true;\n    };\n    SicLiteral.prototype.makeReady = function (loc, tagTab, litTab) {\n        return;\n    };\n    SicLiteral.prototype.toBytes = function () {\n        return SicSpace_1.SicSpace.splitWord(this.val);\n    };\n    return SicLiteral;\n}());\nexports.SicLiteral = SicLiteral;","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SicFmt_1 = require(\"./SicFmt\");\nvar SicLstEntry = (function () {\n    function SicLstEntry(source, bcData) {\n        this.source = source;\n        if (typeof bcData === \"string\") {\n            this.bcData = undefined;\n            this.errmsg = bcData;\n        }\n        else {\n            this.bcData = bcData;\n            this.errmsg = undefined;\n        }\n    }\n    SicLstEntry.prototype.hasInstruction = function () {\n        return this.bcData !== undefined && this.bcData.inst !== undefined;\n    };\n    SicLstEntry.prototype.byteCode = function () {\n        if (!(this.bcData !== undefined && this.bcData.inst !== undefined)) {\n            throw new Error(\"This SicLstEntry does not have an instruction in it\");\n        }\n        return this.bcData.inst.toBytes();\n    };\n    SicLstEntry.prototype.byteString = function () {\n        return SicFmt_1.bytesToString(this.byteCode());\n    };\n    return SicLstEntry;\n}());\nexports.SicLstEntry = SicLstEntry;","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SicPending_1 = require(\"./SicPending\");\nvar SicUnsigned_1 = require(\"./SicUnsigned\");\nvar SicOpAddrType;\n(function (SicOpAddrType) {\n    SicOpAddrType[SicOpAddrType[\"immediate\"] = 0] = \"immediate\";\n    SicOpAddrType[SicOpAddrType[\"direct\"] = 1] = \"direct\";\n    SicOpAddrType[SicOpAddrType[\"indirect\"] = 2] = \"indirect\";\n})(SicOpAddrType = exports.SicOpAddrType || (exports.SicOpAddrType = {}));\nvar SicOpType;\n(function (SicOpType) {\n    SicOpType[SicOpType[\"f3\"] = 0] = \"f3\";\n    SicOpType[SicOpType[\"f4\"] = 1] = \"f4\";\n    SicOpType[SicOpType[\"legacy\"] = 2] = \"legacy\";\n})(SicOpType = exports.SicOpType || (exports.SicOpType = {}));\nvar SicOperandAddr = (function () {\n    function SicOperandAddr(arg, type, csect) {\n        var reDecimal = new RegExp(\"^(=|#|@)?(-?\\\\d+)(,X)?$\");\n        var reHex = new RegExp(\"^(=|#|@)?X'([0-9A-F]+)'(,X)?$\");\n        var reChar = new RegExp(\"^(=|#|@)?C'(.{1,3})'(,X)?$\");\n        var reTag = new RegExp(\"^(#|@)?([A-Z]+)(,X)?$\");\n        var getType = function (char) {\n            switch (char) {\n                case \"#\":\n                    return SicOpAddrType.immediate;\n                case \"@\":\n                    return SicOpAddrType.indirect;\n                case \"=\":\n                default:\n                    return SicOpAddrType.direct;\n            }\n        };\n        var isLiteral = function (c) { return c !== undefined && c.charAt(0) === \"=\"; };\n        this.type = type;\n        this.base = this.type === SicOpType.f3 ? csect.base : undefined;\n        this.pcrel = this.type === SicOpType.f3;\n        var match;\n        if ((match = arg.match(reDecimal)) !== null) {\n            var x = parseInt(match[2], 10);\n            if (isLiteral(match[1])) {\n                csect.litTab.add(x);\n                this.val = new SicPending_1.SicPending(x);\n            }\n            else {\n                this.val = x;\n                this.pcrel = false;\n                this.base = undefined;\n            }\n        }\n        else if ((match = arg.match(reHex)) !== null) {\n            var x = parseInt(match[2], 16);\n            if (isLiteral(match[1])) {\n                csect.litTab.add(x);\n                this.val = new SicPending_1.SicPending(x);\n            }\n            else {\n                this.val = x;\n                this.pcrel = false;\n                this.base = undefined;\n            }\n        }\n        else if ((match = arg.match(reChar)) !== null) {\n            var bytes = [];\n            for (var i = 0; i < match[2].length; ++i) {\n                bytes.push(match[2].charCodeAt(i));\n            }\n            while (bytes.length < 3) {\n                bytes = [0].concat(bytes);\n            }\n            var x = (bytes[0] << 16) + (bytes[1] << 8) + (bytes[2]);\n            if (isLiteral(match[1])) {\n                csect.litTab.add(x);\n                this.val = new SicPending_1.SicPending(x);\n            }\n            else {\n                this.val = x;\n                this.pcrel = false;\n                this.base = undefined;\n            }\n        }\n        else if ((match = arg.match(reTag)) != null) {\n            if (csect.extRefTab.has(match[2])) {\n                if (this.type !== SicOpType.f4) {\n                    throw new Error(\"EXTREF symbols can only be used with format 4\");\n                }\n                csect.modRecs.push({ loc: csect.useTab.aloc, len: 5, symbol: match[2] });\n                this.val = 0;\n                this.pcrel = false;\n            }\n            else {\n                this.val = new SicPending_1.SicPending(match[2]);\n            }\n        }\n        else {\n            throw new Error(\"Operand \" + arg + \" is not of any valid format.\");\n        }\n        this.addr = getType(match[1]);\n        this.indexed = match[3] != null;\n        if (this.addr !== SicOpAddrType.direct && this.type === SicOpType.legacy) {\n            throw new Error(\"SIC Legacy instructions can only use direct addressing\");\n        }\n        this.rdy = !this.pcrel &&\n            this.base === undefined &&\n            typeof this.val === \"number\";\n    }\n    SicOperandAddr.prototype.ready = function () {\n        return this.rdy;\n    };\n    SicOperandAddr.prototype.makeReady = function (pc, tagTab, litTab) {\n        if (this.rdy) {\n            return;\n        }\n        if (this.base !== undefined && !this.base.ready()) {\n            this.base.makeReady(tagTab);\n        }\n        if (typeof this.val !== \"number\") {\n            this.val = this.val.convert(tagTab, litTab);\n        }\n        var opLen;\n        switch (this.type) {\n            case SicOpType.f3:\n                opLen = 12;\n                break;\n            case SicOpType.legacy:\n                opLen = 15;\n                break;\n            case SicOpType.f4:\n                opLen = 20;\n                break;\n            default:\n                throw new Error(\"type is not valid\");\n        }\n        if (this.pcrel) {\n            try {\n                this.val = SicUnsigned_1.sicMakeUnsigned(this.val - pc, opLen);\n                this.rdy = true;\n                return;\n            }\n            catch (e) {\n                this.pcrel = false;\n            }\n        }\n        if (this.base) {\n            try {\n                this.val = SicUnsigned_1.sicMakeUnsigned(this.val - this.base.val, opLen);\n                this.rdy = true;\n                return;\n            }\n            catch (e) {\n                this.base = undefined;\n            }\n        }\n        SicUnsigned_1.sicCheckUnsigned(this.val, opLen);\n        this.rdy = true;\n    };\n    SicOperandAddr.prototype.nixbpe = function () {\n        if (!this.ready()) {\n            throw new Error(\"nixbpe() can only be called when the value is ready.\");\n        }\n        var n;\n        var i;\n        var x = this.indexed;\n        var b = !this.pcrel && this.base !== undefined;\n        var p = this.pcrel;\n        var e = this.type === SicOpType.f4;\n        switch (this.addr) {\n            case SicOpAddrType.direct:\n                if (this.type === SicOpType.legacy) {\n                    n = false;\n                    i = false;\n                }\n                else {\n                    n = true;\n                    i = true;\n                }\n                break;\n            case SicOpAddrType.indirect:\n                n = true;\n                i = false;\n                break;\n            case SicOpAddrType.immediate:\n                n = false;\n                i = true;\n                break;\n            default:\n                throw new Error(\"Registers do not have an nixbpe value\");\n        }\n        var bytes = [0x0, 0x0];\n        if (n) {\n            bytes[0] |= 0x2;\n        }\n        if (i) {\n            bytes[0] |= 0x1;\n        }\n        if (x) {\n            bytes[1] |= 0x80;\n        }\n        if (b) {\n            bytes[1] |= 0x40;\n        }\n        if (p) {\n            bytes[1] |= 0x20;\n        }\n        if (e) {\n            bytes[1] |= 0x10;\n        }\n        return bytes;\n    };\n    return SicOperandAddr;\n}());\nexports.SicOperandAddr = SicOperandAddr;","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SicPending = (function () {\n    function SicPending(val) {\n        this.val = val;\n    }\n    SicPending.prototype.isLiteral = function () {\n        return typeof this.val === \"number\";\n    };\n    SicPending.prototype.isTag = function () {\n        return typeof this.val === \"string\";\n    };\n    SicPending.prototype.convert = function (tagTab, litTab) {\n        var s;\n        if (typeof this.val === \"number\") {\n            if (litTab === null) {\n                throw new Error(\"litTab is undefined but this SicPending is a literal\");\n            }\n            s = litTab.getLitLoc(this.val);\n            if (s === null) {\n                throw new Error(this.val + \"was not found in the literal table\");\n            }\n        }\n        else {\n            if (tagTab === null) {\n                throw new Error(\"tagTab is undefined but this SicPending is a tag\");\n            }\n            s = tagTab[this.val];\n            if (s === null) {\n                throw new Error(this.val + \"was not found in the tag table\");\n            }\n        }\n        return s;\n    };\n    return SicPending;\n}());\nexports.SicPending = SicPending;","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.sicRegToDec = function (reg) {\n    switch (reg) {\n        case \"A\":\n            return 0;\n        case \"X\":\n            return 1;\n        case \"L\":\n            return 2;\n        case \"B\":\n            return 3;\n        case \"S\":\n            return 4;\n        case \"T\":\n            return 5;\n        case \"F\":\n            return 6;\n        case \"PC\":\n            return 8;\n        case \"SW\":\n            return 9;\n        default:\n            throw new Error(\"reg type \" + reg + \" is not valid\");\n    }\n};\nexports.sicDecToReg = function (reg) {\n    switch (reg) {\n        case 0:\n            return \"A\";\n        case 1:\n            return \"X\";\n        case 2:\n            return \"L\";\n        case 3:\n            return \"B\";\n        case 4:\n            return \"S\";\n        case 5:\n            return \"T\";\n        case 6:\n            return \"F\";\n        case 8:\n            return \"PC\";\n        case 9:\n            return \"SW\";\n        default:\n            throw new Error(\"reg no \" + reg + \" is not valid\");\n    }\n};","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SicUnsigned_1 = require(\"./SicUnsigned\");\nvar SicSpace = (function () {\n    function SicSpace(line) {\n        if (!SicSpace.isSpace(line.op)) {\n            throw new Error(\"This mnemonic is not a space.\");\n        }\n        this.mnemonic = line.op;\n        var func = this.mnemonic === \"BYTE\" ? SicSpace.splitByte : SicSpace.splitWord;\n        var reDec = new RegExp(\"^(-?\\\\d+)$\");\n        var reHex = new RegExp(\"^X'([0-9A-Fa-f]+)'$\");\n        var reChar = new RegExp(\"^C'(.+)'$\");\n        var match;\n        if ((match = line.args.match(reDec)) !== null) {\n            this.arg = func(parseInt(match[1], 10));\n        }\n        else if ((match = line.args.match(reHex)) !== null) {\n            this.arg = func(parseInt(match[1], 16));\n        }\n        else if ((match = line.args.match(reChar)) !== null) {\n            this.arg = [];\n            for (var i = 0; i < match[1].length; ++i) {\n                this.arg.push(match[1].charCodeAt(i));\n            }\n        }\n        else {\n            throw new Error(line.args + \" is not a valid operand format.\");\n        }\n    }\n    SicSpace.isSpace = function (mnemonic) {\n        var re = new RegExp(\"^(WORD|BYTE)$\");\n        return re.test(mnemonic);\n    };\n    SicSpace.splitWord = function (n) {\n        if (n >= 0) {\n            SicUnsigned_1.sicCheckUnsigned(n, 24);\n        }\n        else {\n            n = SicUnsigned_1.sicMakeUnsigned(n, 24);\n        }\n        return [(n & 0xFF0000) >>> 16, (n & 0xFF00) >>> 8, (n & 0xFF)];\n    };\n    SicSpace.splitByte = function (n) {\n        if (n >= 0) {\n            SicUnsigned_1.sicCheckUnsigned(n, 8);\n        }\n        else {\n            n = SicUnsigned_1.sicMakeUnsigned(n, 8);\n        }\n        return [0, 0, n];\n    };\n    SicSpace.prototype.ready = function () {\n        return true;\n    };\n    SicSpace.prototype.makeReady = function (loc, tagTab, litTab) {\n        return;\n    };\n    SicSpace.prototype.length = function () {\n        switch (this.mnemonic) {\n            case \"WORD\":\n                return this.arg.length + (this.arg.length % 3 !== 0 ? 1 : 0);\n            case \"BYTE\":\n                return this.arg.length;\n            default:\n                throw new Error(this.mnemonic + \" is invalid. this is a ultra mega bug\");\n        }\n    };\n    SicSpace.prototype.toBytes = function () {\n        var a = [];\n        switch (this.mnemonic) {\n            case \"WORD\":\n                for (var i = 0; i < this.arg.length % 3; ++i) {\n                    a.push(0x00);\n                }\n                this.arg.forEach(function (val) { return a.push(val); });\n                return a;\n            case \"BYTE\":\n                return this.arg;\n            default:\n                throw new Error(\"Mnemonic is invalid.\");\n        }\n    };\n    return SicSpace;\n}());\nexports.SicSpace = SicSpace;","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SicSplit = (function () {\n    function SicSplit(line) {\n        line = line.replace(/\\..*$/, \"\").toUpperCase();\n        var lineArr = line.split(/\\s+/);\n        if (lineArr.length <= 1) {\n            throw new Error(\"This line does not have the correct number of entries. Did you forget to put whitespace before the operand?\");\n        }\n        this.tag = lineArr[0];\n        this.op = lineArr[1];\n        if (lineArr.length >= 3) {\n            this.args = lineArr.slice(2).reduce(function (acc, val) { return acc + val; }, \"\");\n        }\n        else {\n            this.args = \"\";\n        }\n        if (this.tag !== \"\" && this.tag.match(/^[A-Z][A-Z0-9]*$/) === null) {\n            throw new Error(\"Labels must start with A-Z (found \\\"\" + this.tag + \"\\\")\");\n        }\n    }\n    return SicSplit;\n}());\nexports.SicSplit = SicSplit;","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SicFmt_1 = require(\"./SicFmt\");\nexports.sicMakeMask = function (nBits) {\n    var m = 0x0;\n    for (var i = 0; i < nBits; ++i) {\n        m |= (1 << i);\n    }\n    return m;\n};\nexports.sicCheckUnsigned = function (val, nBits) {\n    if (val < 0x0 || val > exports.sicMakeMask(nBits)) {\n        throw new Error(SicFmt_1.asHex(val) + \" does not fit in an unsigned \" + nBits + \"-bit range\");\n    }\n};\nexports.sicMakeUnsigned = function (val, nBits) {\n    var m = exports.sicMakeMask(nBits - 1);\n    if (val < -m - 1 || val > m) {\n        throw new Error(SicFmt_1.asHex(val) + \" does not fit in a signed \" + nBits + \"-bit range\");\n    }\n    val >>>= 0;\n    val &= exports.sicMakeMask(nBits);\n    return val;\n};","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SicUseTab = (function () {\n    function SicUseTab(startloc) {\n        this.ALOC = this.RLOC = this.startloc = startloc;\n        this.useTab = {};\n        this.currentUse = \"\";\n    }\n    Object.defineProperty(SicUseTab.prototype, \"aloc\", {\n        get: function () {\n            return this.ALOC;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SicUseTab.prototype, \"rloc\", {\n        get: function () {\n            return this.RLOC;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    SicUseTab.prototype.inc = function (n) {\n        this.RLOC += n;\n        this.ALOC += n;\n    };\n    SicUseTab.prototype.use = function (label) {\n        this.useTab[this.currentUse] = this.RLOC;\n        this.currentUse = label;\n        var x = this.useTab[label];\n        if (x === undefined) {\n            x = this.startloc;\n        }\n        this.RLOC = x;\n    };\n    return SicUseTab;\n}());\nexports.SicUseTab = SicUseTab;","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nrequire(\"jquery\");\nvar SicCompiler_1 = __importDefault(require(\"./SicCompiler/SicCompiler\"));\nvar editor = ace.edit(\"editor\");\neditor.setTheme(\"ace/theme/monokai\");\neditor.session.setMode(\"ace/mode/sicxe\");\n$(\"#output\").val(\"\");\nvar textToArray = function (innerText) {\n    return innerText.split(\"\\n\");\n};\nvar arrayToText = function (array) {\n    return array.reduce(function (acc, val) { return acc + \"\\n\" + val; });\n};\n$(\"#btnCompile\").click(function () {\n    try {\n        var arr = textToArray(editor.getValue());\n        var comp = new SicCompiler_1.default(arr);\n        var output = [\"-----lst-----\"];\n        output = output.concat(comp.makeLst());\n        if (!comp.err) {\n            output = output.concat(\"\", \"\", \"-----obj-----\");\n            output = output.concat(comp.makeObj());\n        }\n        else {\n            output = output.concat(\"\", \"\", \"No obj generation due to errors in lst.\");\n        }\n        $(\"#output\").val(arrayToText(output));\n    }\n    catch (e) {\n        alert(e.message);\n    }\n});"]}